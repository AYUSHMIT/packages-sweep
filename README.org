#+title:                 sweep: SWI-Prolog Embedded in Emacs
#+author:                Eshel Yaron
#+email:                 me@eshelyaron.com
#+language:              en
#+options:               ':t toc:nil author:t email:t num:nil
#+startup:               content indent
#+export_file_name:      sweep.texi
#+texinfo_filename:      sweep.info
#+texinfo_dir_category:  Emacs
#+texinfo_dir_title:     Sweep: (sweep)
#+texinfo_dir_desc:      SWI-Prolog Embedded in Emacs
#+texinfo_header:        @set MAINTAINERSITE @uref{https://eshelyaron.com,maintainer webpage}
#+texinfo_header:        @set MAINTAINER Eshel Yaron
#+texinfo_header:        @set MAINTAINEREMAIL @email{me@eshelyaron.com}
#+texinfo_header:        @set MAINTAINERCONTACT @uref{mailto:me@eshelyaron.com,contact the maintainer}

This manual describes the Emacs package =sweep=, which provides an
embedded SWI-Prolog runtime inside of Emacs.

#+toc: headlines 8 insert TOC here, with eight headline levels

* Overview
:PROPERTIES:
:CUSTOM_ID: overview
:END:

=sweep= is an embedding of SWI-Prolog in Emacs.  It provides an
interface for executing Prolog queries and consuming their results
from Emacs Lisp (see [[Querying Prolog]]).  =sweep= further builds on top of
this interface and on top of the standard Emacs facilities to provide
advanced features for developing SWI-Prolog programs in Emacs.

** High-level architecture
:PROPERTIES:
:CUSTOM_ID: high-level-architecture
:END:

both SWI-Prolog and Emacs Lisp to create a dynamically loaded Emacs
module that contains the SWI-Prolog runtime.  As such, =sweep= has parts
written in C, in Prolog and in Emacs Lisp.


The different parts of =sweep= are structured as follows:

#+CINDEX: sweep-module
- =sweep.c= defines a dynamic Emacs module which is referred to from
  Elisp as =sweep-module=. This module is linked against the SWI-Prolog
  runtime library (=libswipl=) and exposes a subset of the SWI-Prolog C
  interface to Emacs in the form of Elisp functions (see [[Querying
  Prolog]]). Notably, =sweep-module= is responsible for translating Elisp
  objects to Prolog terms and vice versa.

#+CINDEX: sweep.el
- =sweep.el= defines an Elisp library (named simply =sweep=), which builds
  on top of =sweep-module= to provide user-facing commands and
  functionality. It is also responsible for loading and compiling the
  dynamically loaded =sweep-module=.

#+CINDEX: sweep.pl
- =sweep.pl= defines a Prolog module (named, unsurprisingly, =sweep=)
  which is by default arranged by =sweep.el= to be loaded when the
  embedded Prolog runtime is initialized. It contains predicates that
  =sweep.el= invoke through =sweep-module= to facilitate its different
  commands (see [[Finding Prolog code]]).

* Installation
:PROPERTIES:
:CUSTOM_ID: installation
:END:

1. Clone the =sweep= repository:
   #+begin_src sh
     git clone https://git.sr.ht/~eshel/sweep
   #+end_src

2. Optionally, build the C module =sweep-module=:
   #+begin_src sh
     cd sweep
     make
   #+end_src

3. Add =sweep= to Emacs' =load-path=:
   #+begin_src emacs-lisp
     (add-to-list 'load-path "/path/to/sweep")
   #+end_src

4. Load =sweep= into Emacs:
   #+begin_src emacs-lisp
     (require 'sweep)
   #+end_src

   If =sweep-module= is not already built, =sweep= will suggest to build
   it when loaded.

* Prolog initialization and cleanup
:PROPERTIES:
:CUSTOM_ID: prolog-init
:END:

#+FINDEX: sweep-initialize
The embedded SWI-Prolog runtime must be initialized before it can
start executing queries.  In =sweep=, Prolog initialization is done via
the C-implemented =sweep-initialize= Elisp function defined in
=sweep-module=.  =sweep-initialize= takes one or more arguments, which
must all be strings, and initializes the embedded Prolog as if it were
invoked externally in a command line with the given strings as command
line arguments, where the first argument to =sweep-initialize=
corresponds to =argv[0]=.

#+VINDEX: sweep-init-args
By default, =sweep.el= will initialize Prolog automatically when it is
loaded into Emacs.  The arguments used to initialize Prolog in that
case are determined by the value of the user-option =sweep-init-args=
which the user is free to extend with e.g.:

#+begin_src emacs-lisp
  (add-to-list 'sweep-init-args "--stack-limit=512m")
#+end_src

#+VINDEX: sweep-init-on-load
To inhibit =sweep= from initializing Prolog on load, set the user-option
=sweep-init-on-load= to nil.

#+FINDEX: sweep-cleanup
The embedded Prolog runtime can be reset using the =sweep-cleanup=
function.  This function cleans up the Prolog state and resources,
afterwards =sweep-initialize= can be called to start Prolog anew.

* Querying Prolog
:PROPERTIES:
:CUSTOM_ID: querying-prolog
:END:

#+FINDEX: sweep-open-query
=sweep= provides the Elisp function =sweep-open-query= for invoking Prolog
predicates.  The invoked predicate must be of arity two and will be
called in mode =p(+In, -Out)= i.e. the predicate should treat the first
argument as input and expect a variable for the second argument which
should be unified with some output.  This restriction is placed in
order to facilitate a natural calling convention between Elisp, a
functional language, and Prolog, a logical one.

The =sweep-open-query= function takes five arguments, the first three
are strings which denote:
- The name of the Prolog context module from which to execute the
  query,
- The name of the module in which the invoked predicate is defined,
  and
- The name of the predicate to call.

The fourth argument to =sweep-open-query= is converted into a Prolog
term and used as the first argument of the predicate (see [[Conversion
of Elisp objects to Prolog terms]]).  The fifth argument is an
optional "reverse" flag, when this flag is set to non-nil, the order
of the arguments is reversed such that the predicate is called in mode
=p(-Out, +In)= rather than =p(+In, -Out)=.

#+FINDEX: sweep-next-solution
The function =sweep-next-solution= can be used to examine the results of
a query.  If the query succeeded, =sweep-next-solution= returns a cons
cell whose =car= is either the symbol =!= when the success was
deterministic or =t= otherwise, and the =cdr= is the current value of the
second (output) Prolog argument converted to an Elisp object (see
[[Conversion of Prolog terms to Elisp objects]]).  If the query failed,
=sweep-next-solution= returns nil.


#+FINDEX: sweep-cut-query
#+FINDEX: sweep-close-query
=sweep= only executes one Prolog query at a given time, thus queries
opened with =sweep-open-query= need to be closed before other queries
can be opened.  When no more solutions are available for the current
query (i.e. after =sweep-next-solution= returned nil), or when otherwise
further solutions are not of interest, the query must be closed with
either =sweep-cut-query= or =sweep-close-query=. Both of these functions
close the current query, but =sweep-close-query= also destroys any
Prolog bindings created by the query.

** Conversion of Elisp objects to Prolog terms
:PROPERTIES:
:CUSTOM_ID: elisp-to-prolog
:END:

=sweep= converts Elisp objects into Prolog terms to allow the Elisp
programmers to specify arguments for Prolog predicates invocations (see
=sweep-open-query=).  Seeing as some Elisp objects, like Elisp compiled
functions, wouldn't be as useful for a passing to Prolog as others,
=sweep= only converts Elisp objects of certain types to Prolog, namely
we convert /trees of strings and numbers/:

- Elisp strings are converted to equivalent Prolog strings.
- Elisp integers are converted to equivalent Prolog integers.
- Elisp floats are converted to equivalent Prolog floats.
- The Elisp nil object is converted to the Prolog empty list =[]=.
- Elisp cons cells are converted to Prolog lists whose head and tail
  are the Prolog representations of the =car= and the =cdr= of the cons.

** Conversion of Prolog terms to Elisp objects
:PROPERTIES:
:CUSTOM_ID: prolog-to-elisp
:END:

=sweep= converts Prolog terms into Elisp object to allow efficient
processing of Prolog query results in Elisp (see =sweep-next-solution=).

- Prolog strings are converted to equivalent Elisp strings.
- Prolog integers are converted to equivalent Elisp integers.
- Prolog floats are converted to equivalent Elisp floats.
- A Prolog atom =foo= is converted to a cons cell =(atom . "foo")=.
- The Prolog empty list =[]= is converted to the Elisp nil object.
- Prolog lists are converted to Elisp cons cells whose =car= and =cdr= are
  the representations of the head and the tail of the list.
- Prolog compounds are converted to list whose first element is the
  symbol =compound=. The second element is a string denoting the functor
  name of the compound, and the rest of the elements are the arguments
  of the compound in their Elisp representation.
- All other Prolog terms (variables, blobs and dicts) are currently
  represented in Elisp only by their type:
  + Prolog variables are converted to the symbol =variable=,
  + Prolog blobs are converted to the symbol =blob=, and
  + Prolog dicts are converted to the symbol =dict=.

** Example - counting solutions for a Prolog predicate in Elisp
:PROPERTIES:
:CUSTOM_ID: count-permutations
:END:

As an example of using the =sweep= interface for executing Prolog
queries, we show an invocation of the non-deterministic predicate
=lists:permutation/2= from Elisp where we count the number of different
permutations of the list =(1 2 3 4 5)=:

#+name: count-list-permutations
#+begin_src emacs-lisp
  (sweep-open-query "user" "lists" "permutation" '(1 2 3 4 5))
  (let ((num 0)
        (sol (sweep-next-solution)))
    (while sol
      (setq num (1+ num))
      (setq sol (sweep-next-solution)))
    (sweep-close-query)
    num)
#+end_src

** Calling Elisp function inside Prolog queries
:PROPERTIES:
:CUSTOM_ID: funcall-from-prolog
:END:

The =sweep-module= defines the foreign Prolog predicates =sweep_funcall/2=
and =sweep_funcall/3=, which allow for calling Elisp functions from
Prolog code.  These predicates may only be called in the context of a
Prolog query initiated by =sweep-open-query=, i.e. only in the Prolog
thread controlled by Emacs.  The first argument to these predicates is
a Prolog string holding the name of the Elisp function to call.  The
last argument to these predicates is unified with the return value of
the Elisp function, represented as a Prolog term (see [[Conversion of
Elisp objects to Prolog terms]]).  The second argument of
=sweep_funcall/3= is converted to an Elisp object (see [[Conversion of
Prolog terms to Elisp objects]]) and passed as a sole argument to the
invoked Elisp function.  The =sweep_funcall/2= variant invokes the Elisp
function without any arguments.

* Editing Prolog code
:PROPERTIES:
:CUSTOM_ID: editing-prolog-code
:END:

#+CINDEX: sweep-mode
#+FINDEX: sweep-mode
#+VINDEX: sweep-mode
=sweep= includes a dedicated major mode for reading and editing Prolog
code, called =sweep-mode=.  To activate this mode in a buffer, type =M-x
sweep-mode=.  To instruct Emacs to always open Prolog files in
=sweep-mode=, modify the Emacs variable =auto-mode-alist= like so:

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.pl\\'"   . sweep-mode))
  (add-to-list 'auto-mode-alist '("\\.plt\\'"  . sweep-mode))
#+end_src

** Semantic highlighting
:PROPERTIES:
:CUSTOM_ID: semantic-highlighting
:END:

#+CINDEX: fontification
=sweep-mode= integrates with the standard Emacs =font-lock= system which
is used for highlighting text in buffers (see [[info:emacs#Font Lock][Font Lock in the Emacs
manual]]).  =sweep-mode= highlights different tokens in Prolog code
according to their semantics, determined through static analysis which
is performed on demand.  When a buffer is first opened in =sweep-mode=,
its entire contents are analyzed to collect and cache cross reference
data, and the buffer is highlighted accordingly.  In contrast, when
editing and moving around the buffer, a faster, local analysis is
invoked to updated the semantic highlighting.

#+FINDEX: sweep-colourise-buffer
At any point in a =sweep-mode= buffer, the command =C-c C-c= (or =M-x
sweep-colourise-buffer=) can be used to update the cross reference
cache and highlight the buffer accordingly.  This may be useful
e.g. after defining a new predicate.

#+CINDEX: sweep-faces
=sweep= defines more than 60 different faces (named sets of properties
that determine the appearance of a specific text in Emacs buffers, see
also [[info:emacs#Faces][Faces in the Emacs manual]]) to signify the specific semantics of
each token in a Prolog code buffer.  For example, calls to built in
Prolog predicates are highlighted with the =sweep-built-in-face=, while
recursive calls to predicates in their own definitions are assigned
the =sweep-recursion-face=.  The different appearance properties
associated which each face, like color, font, etc., can be customized
according to best suite the user's preferences.  By default, =sweep=
defines its faces to inherit from standard Emacs faces such as
=font-lock-variable-face= commonly used for variables in different
programming languages, which =sweep= uses a basis for
=sweep-variable-face=.  To view and customize all of the faces defined
and used in =sweep=, type =M-x customize-group RET sweep-faces RET=.

** Definitions and references
:PROPERTIES:
:CUSTOM_ID: sweep-xref
:END:

#+CINDEX: xref
=sweep-mode= integrates with the Emacs =xref= API to facilitate quick
access to predicate definitions and references in Prolog code buffers.
This enables the many commands that the =xref= interface provides, like
=M-.= for jumping to the definition of the predicate at point.  Refer to
[[info:emacs#Find Identifiers][Find Identifiers in the Emacs manual]] for an overview of the available
commands.

* The Prolog top-level
:PROPERTIES:
:CUSTOM_ID: prolog-top-level
:END:

#+CINDEX: top-level
#+FINDEX: sweep-top-level
=sweep= provides a classic Prolog top-level interface for interacting
with the embedded Prolog runtime.  To start the top-level, use =M-x
sweep-top-level=.  This command opens a buffer called =*sweep-top-level*=
which hosts the live Prolog top-level.

#+FINDEX: sweep-top-level-mode
#+VINDEX: sweep-top-level-mode
The top-level buffer uses a major mode named
=sweep-top-level-mode=. This mode derives from =comint-mode=, which is the
common mode used in Emacs REPL interfaces.  As a result, the top-level
buffer inherits the features present in other =comint-mode= derivatives,
most of which are described in [[info:emacs#Shell Mode][the Emacs manual]].

** Multiple top-levels
:PROPERTIES:
:CUSTOM_ID: multiple-top-levels
:END:

Any number of top-levels can be created and used concurrently, each in
its own buffer.  If a top-level buffer already exists, =sweep-top-level=
will simply open it by default.  To create another one or more
top-level buffers, run =sweep-top-level= with a prefix argument
(i.e. =C-u M-x sweep-top-level-mode=) to choose a different buffer name.
Alternatively, run the command =C-x x u= (or =M-x rename-uniquely=) in the
buffer called =*sweep-top-level*= and then run =M-x sweep-top-level=
again.  This will change the name of the original top-level buffer to
something like =*sweep-top-level*<2>= and allow the new top-level to
claim the buffer name =*sweep-top-level*=.

** Completion in the top-level
:PROPERTIES:
:CUSTOM_ID: completion-in-top-level
:END:

The =sweep-top-level-mode=, enabled in the =sweep= top-level buffer,
integrates with the standard Emacs symbol completion mechanism to
provide completion for predicate names.  To complete a partial
predicate name in the top-level prompt, use =C-M-i= (or =M-<TAB>=).  For
more information see [[info:emacs#Symbol Completion][Symbol Completion in the Emacs manual]].

* Finding Prolog code
:PROPERTIES:
:CUSTOM_ID: finding-prolog-code
:END:

#+FINDEX: sweep-find-module
=sweep= provides the command =M-x sweep-find-module= for
selecting and jumping to the source code of a loaded or auto-loadable
Prolog module.  =sweep= integrates with Emacs' standard completion API
to annotate candidate modules in the completion UI with their =PLDoc=
description when available.

#+FINDEX: sweep-find-predicate
Along with =M-x sweep-find-module=, =sweep= provides the
command =M-x sweep-find-predicate= jumping to the definition a
loaded or auto-loadable Prolog predicate.

** Prolog file specification expansion
:PROPERTIES:
:CUSTOM_ID: file-spec-expansion
:END:

=sweep= defines a handler for the Emacs function =expand-file-file= that
recognizes Prolog file specifications, such as =library(lists)=, and
expands them to their corresponding absolute paths.  This means that
one can use Prolog file specifications with Emacs' standard =find-file=
(=C-x C-f=) to locate Prolog resources directly.

For example, typing =C-x C-f library(pldoc/doc_man)= will open the
source of the =pldoc_man= module from the Prolog library, and likewise
=C-x C-f pack(.)= will open the Prolog packages directory.

* Quick access to =sweep= commands
:PROPERTIES:
:CUSTOM_ID: quick-command-access
:END:

#+VINDEX: sweep-prefix-map
=sweep= defines a keymap called =sweep-prefix-map= which provides
keybinding for several useful =sweep= commands.  By default,
=sweep-prefix-map= itself is not bound to any key.  To bind it globally
to a prefix key, e.g. =C-c p=, use:

#+begin_src emacs-lisp
  (keymap-global-set "C-c p" sweep-prefix-map)
#+end_src

As an example, with the above binding the =sweep= top-level can be
accessed from anywhere with =C-c p t=, which invokes the command
=sweep-top-level=.

* Examining Prolog messages
:PROPERTIES:
:CUSTOM_ID: prolog-messages
:END:

#+CINDEX: messages
#+VINDEX: sweep-messages-buffer-name
Messages emitted by the embedded Prolog are redirected by =sweep= to a
dedicated Emacs buffer.  By default, the =sweep= messages buffer is
named =*sweep Messages*=.  To instruct =sweep= to use another buffer name
instead, type =M-x customize-option RET sweep-messages-buffer-name RET=
and set the option to a suitable value.

The =sweep= messages buffer uses the minor mode =compilation-minor-mode=,
which allows for jumping to source locations indicated in errors and
warning directly from the corresponding message in the =sweep= messages
buffer.  For more information about the features enabled by
=compilation-minor-mode=, see [[info:emacs#Compilation Mode][Compilation Mode in the Emacs manual]].

#+FINDEX: sweep-view-messages
=sweep= includes the command =sweep-view-messages= for quickly switching
to the =sweep= messages buffer.  This command is bound by default in
=sweep-prefix-map= to the =e= key (see [[Quick access to =sweep= commands]]).

* Setting Prolog flags
:PROPERTIES:
:CUSTOM_ID: prolog-flags
:END:

#+CINDEX: prolog flags
#+FINDEX: sweep-set-prolog-flag
The command =M-x sweep-set-prolog-flag= can be used to interactively
configure the embedded Prolog execution environment by changing the
values of Prolog flags.  This command first prompts the user for a
Prolog flag to set, with completion candidates annotated with their
current values as Prolog flags, and then prompts for a string that
will be read as a Prolog term and set as the value of the chosen flag.
For more information on Prolog flags in SWI-Prolog see [[https://www.swi-prolog.org/pldoc/man?section=flags][Environment
Control in the SWI-Prolog manual]].

As an example, the Prolog flag =double_quotes= controls the
interpretation of double quotes in Prolog code.  By default,
=double_quotes= is set to =string=, so e.g. ="foo"= is read as a SWI-Prolog
string as we can easily validate in the =sweep= top-level:

#+begin_src prolog
?- A = "foo".
A = "foo".
#+end_src

We can change the interpretation of double quotes to denote lists of
character codes, by setting the value the =double_quotes= flag to =codes=
with =M-x sweep-set-prolog-flag RET double_quotes RET codes RET=.
Evaluating =A = "foo"= again exhibits the different interpretation:

#+begin_src prolog
?- A = "foo".
A = [102, 111, 111].
#+end_src

* Installing Prolog packages
:PROPERTIES:
:CUSTOM_ID: prolog-packages
:END:

#+FINDEX: sweep-pack-install
The command =M-x sweep-pack-install= can be used to install
or upgrade a SWI-Prolog =pack=. When selecting a =pack= to install, the
completion candidates are annotated with description and the version
of each package.


#+html: <!--

* Indices
:PROPERTIES:
:CUSTOM_ID: indices
:END:

** Function index
:PROPERTIES:
:INDEX: fn
:CUSTOM_ID: findex
:END:

** Variable index
:PROPERTIES:
:INDEX: vr
:CUSTOM_ID: vindex
:END:

** Concept index
:PROPERTIES:
:INDEX: cp
:CUSTOM_ID: cindex
:END:

#+html: -->
