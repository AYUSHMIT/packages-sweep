#+title:                 sweep: SWI-Prolog Embedded in Emacs
#+author:                Eshel Yaron
#+email:                 me@eshelyaron.com
#+language:              en
#+options:               ':t toc:nil author:t email:t num:nil ^:{}
#+startup:               content indent
#+export_file_name:      sweep.texi
#+texinfo_filename:      sweep.info
#+texinfo_dir_category:  Emacs
#+texinfo_dir_title:     Sweep: (sweep)
#+texinfo_dir_desc:      SWI-Prolog Embedded in Emacs
#+texinfo_header:        @set MAINTAINERSITE @uref{https://eshelyaron.com,maintainer webpage}
#+texinfo_header:        @set MAINTAINER Eshel Yaron
#+texinfo_header:        @set MAINTAINEREMAIL @email{me@eshelyaron.com}
#+texinfo_header:        @set MAINTAINERCONTACT @uref{mailto:me@eshelyaron.com,contact the maintainer}

This manual describes the Emacs package =sweep= (or =sweeprolog=), which
provides an embedded SWI-Prolog runtime inside of Emacs.

#+toc: headlines 8 insert TOC here, with eight headline levels

* Overview
:PROPERTIES:
:CUSTOM_ID: overview
:END:

=sweep= is an embedding of SWI-Prolog in Emacs.  It provides an
interface for executing Prolog queries and consuming their results
from Emacs Lisp (see [[Querying Prolog]]).  =sweep= further builds on top of
this interface and on top of the standard Emacs facilities to provide
advanced features for developing SWI-Prolog programs in Emacs.

** High-level architecture
:PROPERTIES:
:CUSTOM_ID: high-level-architecture
:END:

=sweep= uses the C interfaces of both SWI-Prolog and Emacs Lisp to
create a dynamically loaded Emacs module that contains the SWI-Prolog
runtime.  As such, =sweep= has parts written in C, in Prolog and in
Emacs Lisp.

The different parts of =sweep= are structured as follows:

#+CINDEX: sweep-module
- =sweep.c= defines a dynamic Emacs module which is referred to from
  Elisp as =sweep-module=. This module is linked against the SWI-Prolog
  runtime library (=libswipl=) and exposes a subset of the SWI-Prolog C
  interface to Emacs in the form of Elisp functions (see [[Querying
  Prolog]]). Notably, =sweep-module= is responsible for translating Elisp
  objects to Prolog terms and vice versa.

#+CINDEX: sweeprolog.el
- =sweeprolog.el= defines an Elisp library (named simply =sweeprolog=), which builds
  on top of =sweep-module= to provide user-facing commands and
  functionality. It is also responsible for loading and compiling the
  dynamically loaded =sweep-module=.

#+CINDEX: sweep.pl
- =sweep.pl= defines a Prolog module (named, unsurprisingly, =sweep=)
  which is by default arranged by =sweeprolog.el= to be loaded when the
  embedded Prolog runtime is initialized. It contains predicates that
  =sweeprolog.el= invoke through =sweep-module= to facilitate its different
  commands (see [[Finding Prolog code]]).

* Installation
:PROPERTIES:
:CUSTOM_ID: installation
:END:

The dynamic Emacs module =sweep-module= is included in the SWI-Prolog
distribution from version 8.5.18.  For instructions on how to build
and install SWI-Prolog, see [[https://www.swi-prolog.org/build/]].

The =sweeprolog= Elisp package is available on NonGNU ELPA, to install
=sweeprolog= simply type =M-x package-install RET sweeprolog RET=.

An alternative to installing from ELPA is to get the Elisp library
from the =sweep= Git repository:

1. Clone the =sweep= repository:
   #+begin_src sh
     git clone https://git.sr.ht/~eshel/sweep
   #+end_src

   Or:

   #+begin_src sh
     git clone https://github.com/SWI-Prolog/packages-sweep sweep
   #+end_src

2. Add =sweep= to Emacs' =load-path=:
   #+begin_src emacs-lisp
     (add-to-list 'load-path "/path/to/sweep")
   #+end_src

* Getting started
:PROPERTIES:
:CUSTOM_ID: getting-started
:END:

After installing the =sweeprolog= Elisp library, load it into Emacs:

#+begin_src emacs-lisp
  (require 'sweeprolog)
#+end_src

All set!  =sweeprolog= automatically loads =sweep-module= and initializes
the embedded SWI-Prolog runtime.  For a description of the different
features of =sweep=, see the following sections of this manual.

_Important note for Linux users_: prior to version 29, Emacs would load
dynamic modules in a way that is not fully compatible with the way the
SWI-Prolog native library, =libswipl=, loads its own native extensions.
This may lead to =sweep= failing after loading =sweep-module=.  To work
around this issue, users running Emacs 28 or earlier on Linux can
start Emacs with =libswipl= loaded upfront via =LD_PRELOAD=, for example:

#+begin_src sh
  LD_PRELOAD=/usr/local/lib/libswipl.so emacs
#+end_src

* Prolog initialization and cleanup
:PROPERTIES:
:CUSTOM_ID: prolog-init
:END:

#+FINDEX: sweeprolog-initialize
The embedded SWI-Prolog runtime must be initialized before it can
start executing queries.  In =sweep=, Prolog initialization is done via
the C-implemented =sweeprolog-initialize= Elisp function defined in
=sweep-module=.  =sweeprolog-initialize= takes one or more arguments, which
must all be strings, and initializes the embedded Prolog as if it were
invoked externally in a command line with the given strings as command
line arguments, where the first argument to =sweeprolog-initialize=
corresponds to =argv[0]=.

#+VINDEX: sweeprolog-init-args
By default, =sweeprolog.el= will initialize Prolog automatically when it is
loaded into Emacs.  The arguments used to initialize Prolog in that
case are determined by the value of the user-option =sweeprolog-init-args=
which the user is free to extend with e.g.:

#+begin_src emacs-lisp
  (add-to-list 'sweeprolog-init-args "--stack-limit=512m")
#+end_src

#+VINDEX: sweeprolog-init-on-load
To inhibit =sweeprolog= from initializing Prolog on load, set the user-option
=sweeprolog-init-on-load= to nil.

#+FINDEX: sweeprolog-restart
The embedded Prolog runtime can be reset using the command
=sweeprolog-restart=.  This command cleans up the the Prolog state and
resources, and starts it anew.  When called with a prefix argument
(=C-u M-x sweeprolog-restart=), this command prompts the user for
additional initialization arguments to pass to the embedded Prolog
runtime on startup.

* Querying Prolog
:PROPERTIES:
:CUSTOM_ID: querying-prolog
:END:

#+FINDEX: sweeprolog-open-query
=sweep= provides the Elisp function =sweeprolog-open-query= for invoking Prolog
predicates.  The invoked predicate must be of arity two and will be
called in mode =p(+In, -Out)= i.e. the predicate should treat the first
argument as input and expect a variable for the second argument which
should be unified with some output.  This restriction is placed in
order to facilitate a natural calling convention between Elisp, a
functional language, and Prolog, a logical one.

The =sweeprolog-open-query= function takes five arguments, the first three
are strings which denote:
- The name of the Prolog context module from which to execute the
  query,
- The name of the module in which the invoked predicate is defined,
  and
- The name of the predicate to call.

The fourth argument to =sweeprolog-open-query= is converted into a Prolog
term and used as the first argument of the predicate (see [[Conversion
of Elisp objects to Prolog terms]]).  The fifth argument is an
optional "reverse" flag, when this flag is set to non-nil, the order
of the arguments is reversed such that the predicate is called in mode
=p(-Out, +In)= rather than =p(+In, -Out)=.

#+FINDEX: sweeprolog-next-solution
The function =sweeprolog-next-solution= can be used to examine the results of
a query.  If the query succeeded, =sweeprolog-next-solution= returns a cons
cell whose =car= is either the symbol =!= when the success was
deterministic or =t= otherwise, and the =cdr= is the current value of the
second (output) Prolog argument converted to an Elisp object (see
[[Conversion of Prolog terms to Elisp objects]]).  If the query failed,
=sweeprolog-next-solution= returns nil.

#+FINDEX: sweeprolog-cut-query
#+FINDEX: sweeprolog-close-query
=sweep= only executes one Prolog query at a given time, thus queries
opened with =sweeprolog-open-query= need to be closed before other queries
can be opened.  When no more solutions are available for the current
query (i.e. after =sweeprolog-next-solution= returned nil), or when otherwise
further solutions are not of interest, the query must be closed with
either =sweeprolog-cut-query= or =sweeprolog-close-query=. Both of these functions
close the current query, but =sweeprolog-close-query= also destroys any
Prolog bindings created by the query.

** Conversion of Elisp objects to Prolog terms
:PROPERTIES:
:CUSTOM_ID: elisp-to-prolog
:END:

=sweep= converts Elisp objects into Prolog terms to allow the Elisp
programmers to specify arguments for Prolog predicates invocations (see
=sweeprolog-open-query=).  Seeing as some Elisp objects, like Elisp compiled
functions, wouldn't be as useful for a passing to Prolog as others,
=sweep= only converts Elisp objects of certain types to Prolog, namely
we convert /trees of strings and numbers/:

- Elisp strings are converted to equivalent Prolog strings.
- Elisp integers are converted to equivalent Prolog integers.
- Elisp floats are converted to equivalent Prolog floats.
- The Elisp nil object is converted to the Prolog empty list =[]=.
- Elisp cons cells are converted to Prolog lists whose head and tail
  are the Prolog representations of the =car= and the =cdr= of the cons.

** Conversion of Prolog terms to Elisp objects
:PROPERTIES:
:CUSTOM_ID: prolog-to-elisp
:END:

=sweep= converts Prolog terms into Elisp object to allow efficient
processing of Prolog query results in Elisp (see =sweeprolog-next-solution=).

- Prolog strings are converted to equivalent Elisp strings.
- Prolog integers are converted to equivalent Elisp integers.
- Prolog floats are converted to equivalent Elisp floats.
- A Prolog atom =foo= is converted to a cons cell =(atom . "foo")=.
- The Prolog empty list =[]= is converted to the Elisp nil object.
- Prolog lists are converted to Elisp cons cells whose =car= and =cdr= are
  the representations of the head and the tail of the list.
- Prolog compounds are converted to list whose first element is the
  symbol =compound=. The second element is a string denoting the functor
  name of the compound, and the rest of the elements are the arguments
  of the compound in their Elisp representation.
- All other Prolog terms (variables, blobs and dicts) are currently
  represented in Elisp only by their type:
  + Prolog variables are converted to the symbol =variable=,
  + Prolog blobs are converted to the symbol =blob=, and
  + Prolog dicts are converted to the symbol =dict=.

** Example - counting solutions for a Prolog predicate in Elisp
:PROPERTIES:
:CUSTOM_ID: count-permutations
:END:

As an example of using the =sweep= interface for executing Prolog
queries, we show an invocation of the non-deterministic predicate
=lists:permutation/2= from Elisp where we count the number of different
permutations of the list =(1 2 3 4 5)=:

#+name: count-list-permutations
#+begin_src emacs-lisp
  (sweeprolog-open-query "user" "lists" "permutation" '(1 2 3 4 5))
  (let ((num 0)
        (sol (sweeprolog-next-solution)))
    (while sol
      (setq num (1+ num))
      (setq sol (sweeprolog-next-solution)))
    (sweeprolog-close-query)
    num)
#+end_src

** Calling Elisp function inside Prolog queries
:PROPERTIES:
:CUSTOM_ID: funcall-from-prolog
:END:

The =sweep-module= defines the foreign Prolog predicates =sweep_funcall/2=
and =sweep_funcall/3=, which allow for calling Elisp functions from
Prolog code.  These predicates may only be called in the context of a
Prolog query initiated by =sweeprolog-open-query=, i.e. only in the Prolog
thread controlled by Emacs.  The first argument to these predicates is
a Prolog string holding the name of the Elisp function to call.  The
last argument to these predicates is unified with the return value of
the Elisp function, represented as a Prolog term (see [[Conversion of
Elisp objects to Prolog terms]]).  The second argument of
=sweep_funcall/3= is converted to an Elisp object (see [[Conversion of
Prolog terms to Elisp objects]]) and passed as a sole argument to the
invoked Elisp function.  The =sweep_funcall/2= variant invokes the Elisp
function without any arguments.

* Editing Prolog code
:PROPERTIES:
:CUSTOM_ID: editing-prolog-code
:END:

#+CINDEX: sweeprolog-mode
#+FINDEX: sweeprolog-mode
#+VINDEX: sweeprolog-mode
=sweep= includes a dedicated major mode for reading and editing Prolog
code, called =sweeprolog-mode=.  To activate this mode in a buffer, type =M-x
sweeprolog-mode=.  To instruct Emacs to always open Prolog files in
=sweeprolog-mode=, modify the Emacs variable =auto-mode-alist= like so:

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.pl\\'"   . sweeprolog-mode))
  (add-to-list 'auto-mode-alist '("\\.plt\\'"  . sweeprolog-mode))
#+end_src

** Indentation
:PROPERTIES:
:CUSTOM_ID: indentation
:END:

#+CINDEX: indentation

In =sweeprolog-mode= buffers, the appropriate indentation for each line is
determined by a bespoke /indentation engine/.  The indentation engine
analyses the syntactic context of a given line and determines the
appropriate indentation to apply based on a set of rules.

#+FINDEX: sweeprolog-indent-line
The entry point of the indentation engine is the function
=sweeprolog-indent-line= which takes no arguments and indents that line at
point.  =sweeprolog-mode= supports the standard Emacs interface for
indentation by arranging for =sweeprolog-indent-line= to be called whenever a
line should be indented, notably after pressing =TAB=.  For more a full
description of the available commands and options that pertain to
indentation, see [[info:emacs#Indentation][Indentation in the Emacs manual]].

*** Indentation rules
:PROPERTIES:
:CUSTOM_ID: indentation-rules
:END:

Lines in =sweeprolog-mode= buffers are indented according to the following
rules:

1. If the current line starts inside a string or a multi-line comment,
   do not indent.
2. If the current line starts with a top term, do not indent.
3. If the current line starts with a closing parenthesis and the
   matching opening parenthesis is part of a functor, indent to the
   column of the opening parenthesis if any arguments appear on the
   same line as the functor, otherwise indent to the start of the
   functor.

   This rule yields the following layouts:

   #+begin_src prolog
     some_functor(
         some_arg
     ).

     some_functor( some_arg
                 ).
   #+end_src

#+VINDEX: sweeprolog-indent-offset
4. If the current line is the first non-comment line of a clause body,
   indent to the starting column of the head term plus the value of
   the user option =sweeprolog-indent-offset= (by default, four extra
   columns).

   As an example, this rule yields the following layouts when
   =sweeprolog-indent-offset= is set to the default value of four columns:

   #+begin_src prolog
     some_functor(arg1, arg2) :-
         body_term.

     asserta( some_functor(arg1, arg2) :-
                  body_term
            ).
   #+end_src

5. If the current line starts with the right hand side operand of an
   infix operator, indent to the starting column of the first operand
   in the chain of infix operators of the same precedence.

   This rule yields the following layouts:

   #+begin_src prolog
     head :- body1, body2, body3,
             body4, body5.

     A is 1 * 2 ^ 3 * 4 *
          5.

     A is 1 * 2 + 3 * 4 *
                  5.
   #+end_src

6. If the last non-comment line ends with a functor and its opening
   parenthesis, indent to the starting column of the functor plus
   =sweeprolog-indent-offset=.

   This rule yields the following layout:

   #+begin_src prolog
     some_functor(
         arg1, ...
   #+end_src

7. If the last non-comment line ends with a prefix operator, indent to
   starting column of the operator plus =sweeprolog-indent-offset=.

   This rule yields the following layout:

   #+begin_src prolog
     :- multifile
            predicate/3.
   #+end_src

** Semantic highlighting
:PROPERTIES:
:CUSTOM_ID: semantic-highlighting
:END:

#+CINDEX: fontification
=sweeprolog-mode= integrates with the standard Emacs =font-lock= system which
is used for highlighting text in buffers (see [[info:emacs#Font Lock][Font Lock in the Emacs
manual]]).  =sweeprolog-mode= highlights different tokens in Prolog code
according to their semantics, determined through static analysis which
is performed on demand.  When a buffer is first opened in =sweeprolog-mode=,
its entire contents are analyzed to collect and cache cross reference
data, and the buffer is highlighted accordingly.  In contrast, when
editing and moving around the buffer, a faster, local analysis is
invoked to updated the semantic highlighting in response to changes in
the buffer.

#+FINDEX: sweeprolog-colourise-buffer
At any point in a =sweeprolog-mode= buffer, the command =C-c C-c= (or =M-x
sweeprolog-colourise-buffer=) can be used to update the cross reference
cache and highlight the buffer accordingly.  This may be useful
e.g. after defining a new predicate.

#+VINDEX: sweeprolog-colourise-buffer-on-idle
#+VINDEX: sweeprolog-colourise-buffer-max-size
#+VINDEX: sweeprolog-colourise-buffer-min-interval
If the user option =sweeprolog-colourise-buffer-on-idle= is set to non-nil
(as it is by default), =sweeprolog-mode= also updates semantic highlighting
in the buffer whenever Emacs is idle for a reasonable amount of time,
unless the buffer is larger than the value of the
=sweeprolog-colourise-buffer-max-size= user option ( 100,000 by default).
The minimum idle time to wait before automatically updating semantic
highlighting can be set via the user option
=sweeprolog-colourise-buffer-min-interval=.

#+CINDEX: sweeprolog-faces
=sweep= defines three highlighting /styles/, each containing more than 60
different faces (named sets of properties that determine the
appearance of a specific text in Emacs buffers, see also [[info:emacs#Faces][Faces in the
Emacs manual]]) to signify the specific semantics of each token in a
Prolog code buffer.

To view and customize all of the faces defined and used in =sweep=, type
=M-x customize-group RET sweeprolog-faces RET=.

*** Available styles
:PROPERTIES:
:CUSTOM_ID: highlighting-styles
:END:

=sweep= comes with three highlighting styles:

- The =default= style includes faces that mostly inherit from standard
  Emacs faces commonly used in programming modes.
- The =light= style mimics the colors used in the SWI-Prolog built-in
  editor.
- The =dark= style mimics the colors used in the SWI-Prolog built-in
  editor in dark mode.

#+VINDEX: sweeprolog-faces-style
To choose a style, customize the user option =sweeprolog-faces-style= with
=M-x customize-option RET sweeprolog-faces-style RET=.  The new style will
apply to all new =sweeprolog-mode= buffers.  To apply the new style to an
existing buffer, use =C-x x f= (=font-lock-update=) in that buffer.

*** Highlighting occurrences of a variable
:PROPERTIES:
:CUSTOM_ID: variable-highlighting
:END:

#+CINDEX: variable highlighting
=sweeprolog-mode= can highlight all occurrences of a given Prolog
variable in the clause in which it appears.  By default, occurrences
of the variable at point are highlighted automatically whenever the
cursor is moved into a variable.  To achieve this, =sweep= uses the
Emacs minor mode =cursor-sensor-mode= which allows for running hooks
when the cursor enters or leaves certain text regions (see also [[info:elisp#Special
Properties][Special Properties in the Elisp manual]]).

#+VINDEX: sweeprolog-enable-cursor-sensor
To disable automatic variable highlighting based on the variable at
point, customize the variable =sweeprolog-enable-cursor-sensor= to nil.

#+FINDEX: sweeprolog-highlight-variable
To manually highlight occurrences of a variable in the clause
surrounding point, =sweeprolog-mode= provides the command =M-x
sweeprolog-highlight-variable=.  This command prompts for variable to
highlight, defaulting to the variable at point, if any.  If called
with a prefix argument (=C-u M-x sweeprolog-highlight-variable=), it
clears all variable highlighting in the current clause instead.

*** Quasi-quotation highlighting
:PROPERTIES:
:CUSTOM_ID: qq-highlighting
:END:

Quasi-quotations in =sweeprolog-mode= buffer are highlighted according
to the Emacs mode corresponding to the quoted language by default.

#+VINDEX: sweeprolog-qq-mode-alist
The association between SWI-Prolog quasi-quotation types and Emacs
major modes is determined by the user option =sweeprolog-qq-mode-alist=.
To modify the default associations provided by =sweeprolog-mode=, type
=M-x customize-option RET sweeprolog-qq-mode-alist RET=.

If a quasi-quotation type does not have a matching mode in
=sweeprolog-qq-mode-alist=, the function =sweeprolog-qq-content-face= is
used to determine a default face for quoted content.

For more information about quasi-quotations in SWI-Prolog, see
[[https://www.swi-prolog.org/pldoc/man?section=quasiquotations][library(quasi_quotations) in the SWI-Prolog manual]].


** Aligning with multiple spaces
:PROPERTIES:
:CUSTOM_ID: whitespace
:END:

#+CINDEX: whitespace
By convention, if-then-else constructs are aligned such that each goal
starts at the fourth column after the /start/ of the opening parenthesis
or operator, as follows:

  #+begin_src prolog
    (   if
    ->  then
    ;   else
    ,*-> elif
    ;   true
    )
  #+end_src

To simplify maintaining the desired layout without manually counting
spaces, ~sweep~ provides a command that updates the whitespace around
point such that the next token is aligned to a (multiple of) four
columns from the start of the previous token.

#+FINDEX: sweeprolog-align-spaces
#+FINDEX: cycle-spacing
To insert or update whitespace around point, use the command ~M-x
sweeprolog-align-spaces~.  For example, consider a ~sweeprolog-mode~
buffer with the following contents, where =^= designates the location of
the cursor:

#+begin_src prolog
  foo :-
      (   if
      ;
       ^
#+end_src

Calling ~M-x sweeprolog-align-spaces~ will insert three spaces, to yield
the expected layout:

#+begin_src prolog
  foo :-
      (   if
      ;
          ^
#+end_src

In Emacs 29, the command ~M-x cycle-spacing~ is extensible through a
list of callback functions stored in the variable
~cycle-spacing-actions~.  ~sweep~ leverages this facility and adds
~sweeprolog-align-spaces~ as the first action of ~cycle-spacing~.  To
inhibit this ~sweeprolog-mode~ from doing so, set the user option
~sweeprolog-enable-cycle-spacing~ to nil.

Moreover, in Emacs 29 ~cycle-spacing~ is bound by default to ~M-SPC~, thus
aligning if-then-else and similar constructs only requires typing
~M-SPC~ after the first token.

In Emacs prior to version 29, users are advised to bind
~sweeprolog-align-spaces~ to ~M-SPC~ directly by adding the following
lines to Emacs' initialization file (see [[info:emacs#Init File][The Emacs Initialization File]]).

#+begin_src emacs-lisp
  (eval-after-load 'sweeprolog
    '(define-key sweeprolog-mode-map (kbd "M-SPC") #'sweeprolog-align-spaces))
#+end_src

** Term-based editing and motion commands
:PROPERTIES:
:CUSTOM_ID: term-based-commands
:END:

#+CINDEX: sexps
Emacs includes many useful features for operating on syntactic units
in source code buffer, such as marking, transposing and moving over
expressions.  By default, these features are geared towards working
with Lisp expressions, or "sexps".  =sweeprolog-mode= extends the Emacs'
notion of syntactic expressions to accommodate for Prolog terms, which
allows the standard sexp-based commands to operate on them seamlessly.

#+FINDEX: raise-sexp
[[info:emacs#Expressions][Expressions in the Emacs manual]] covers the most important commands
that operate on sexps, and by extension on Prolog terms.  Another
useful command for Prolog programmers is =M-x kill-backward-up-list=,
bound by default to =C-M-^= in =sweeprolog-mode= buffers.  This command
replaces the parent term containing the term at point with the term
itself.  To illustrate the utility of this command, consider the
following clause:

#+begin_src prolog
  head :-
      goal1,
      setup_call_cleanup(setup,
                         goal2,
                         cleanup).
#+end_src

Now with point anywhere inside =goal2=, calling =kill-backward-up-list=
removes the =setup_call_cleanup/3= term leaving =goal2= to be called
directly:

#+begin_src prolog
  head :-
      goal1,
      goal2.
#+end_src

** Definitions and references
:PROPERTIES:
:CUSTOM_ID: sweeprolog-xref
:END:

#+CINDEX: xref
=sweeprolog-mode= integrates with the Emacs =xref= API to facilitate quick
access to predicate definitions and references in Prolog code buffers.
This enables the many commands that the =xref= interface provides, like
=M-.= for jumping to the definition of the predicate at point.  Refer to
[[info:emacs#Find Identifiers][Find Identifiers in the Emacs manual]] for an overview of the available
commands.

#+CINDEX: imenu
=sweeprolog-mode= also integrates with Emacs' =imenu=, which provides a simple
facility for looking up and jumping to definitions in the current
buffer.  To jump to a definition in the current buffer, type =M-x imenu=
(bound by default to =M-g i= in Emacs version 29).  For information
about customizing =imenu=, see [[info:emacs#Imenu][Imenu in the Emacs manual]].

** Following file specifications
:PROPERTIES:
:CUSTOM_ID: following-file-specs
:END:

#+FINDEX: sweeprolog-find-file-at-point
File specifications that occur in =sweeprolog-mode= buffers can be followed
with =C-c C-o= (or =M-x sweeprolog-find-file-at-point=) whenever point is over
a valid file specification.  For example, consider a Prolog file buffer with the common
directive =use_module/1=:

#+begin_src prolog
:- use_module(library(lists)).
#+end_src

With point in any position inside =library(lists)=, typing =C-c C-o= will
open the =lists.pl= file in the Prolog library.

For more information about file specifications in SWI-Prolog, see
[[https://www.swi-prolog.org/pldoc/doc_for?object=absolute_file_name/3][absolute_file_name/3]] in the SWI-Prolog manual.

** Loading buffers
:PROPERTIES:
:CUSTOM_ID: loading-buffers
:END:

#+CINDEX: loading
#+FINDEX: sweeprolog-load-buffer
The command =M-x sweeprolog-load-buffer= can be used to load the contents of
a =sweeprolog-mode= buffer into the embedded SWI-Prolog runtime.  After a
buffer is loaded, the predicates it defines can be queried from Elisp
(see [[Querying Prolog]]) and from the =sweep= top-level (see [[The Prolog
top-level]]).  In =sweeprolog-mode= buffers, =sweeprolog-load-buffer= is bound by
default to =C-c C-l=.  By default this command loads the current buffer
if its major mode is =sweeprolog-mode=, and prompts for an appropriate buffer
otherwise.  To choose a different buffer to load while visiting a
=sweeprolog-mode= buffer, invoke =sweeprolog-load-buffer= with a prefix argument
(=C-u C-c C-l=).

More relevant information about loading code in SWI-Prolog can be
found in [[https://www.swi-prolog.org/pldoc/man?section=consulting][Loading Prolog source files]] in the SWI-Prolog manual.

** Using templates for creating new modules
:PROPERTIES:
:CUSTOM_ID: auto-insert
:END:

#+CINDEX: auto-insert
=sweep= integrates with the Emacs =auto-insert= facility to simplify
creation of new SWI-Prolog modules.  =auto-insert= allows for populating
newly created files with templates defined by the relevant major mode.

=sweep= associates a Prolog module skeleton with =sweeprolog-mode=, the
skeleton begins with a "file header" multi-line comment which includes
the name and email address of the user based on the values of
=user-full-name= and =user-mail-address= respectively.  A =module/2=
directive is placed after the file header, with the module name set to
the base name of the file.  Lastly the skeleton inserts a =PlDoc= module
comment to be filled with the module's documentation (see [[https://www.swi-prolog.org/pldoc/man?section=sectioncomments][File
comments in the SWI-Prolog manual]]).

As an example, after inserting the module skeleton, a new Prolog file
=foo.pl= will have the following contents:

#+begin_src prolog
  /*
      Author:        John Doe
      Email:         john.doe@example.com

  ,*/

  :- module(foo, []).

  /** <module> foo

  ,*/

#+end_src

#+VINDEX: sweeprolog-module-header-comment-skeleton
The multi-line comment included above the =module/2= directive can be
extended by customizing the user option
=sweeprolog-module-header-comment-skeleton=, which see.  This can be
useful for including e.g. copyright text in the file header.

To open a new Prolog file, use the standard =C-x C-f= (=find-file=) and
select a location for the new file.  In the new =sweeprolog-mode=
buffer, type =M-x auto-insert= to insert the Prolog module skeleton.

To automatically insert the module skeleton when opening new files in
=sweeprolog-mode=, enable the minor mode =auto-insert-mode=.  For detailed
information about =auto-insert= and its customization options, see
[[info:autotype#Autoinserting][Autoinserting in the Autotyping manual]].

** Documenting predicates
:PROPERTIES:
:CUSTOM_ID: sweeprolog-pldoc
:END:

#+CINDEX: pldoc
SWI-Prolog predicates can be documented with specially structured
comments placed above the predicate definition, which are processed by
the =PlDoc= source documentation system.  Emacs comes with many useful
commands specifically intended for working with comments in
programming languages, which apply also to writing =PlDoc= comments for
Prolog predicates.  For an overview of the relevant standard Emacs
commands, see [[info:emacs#Comment Commands][Comment Commands in the Emacs manual]].

#+FINDEX: sweeprolog-document-predicate-at-point
=sweep= also includes a dedicated command called
=sweeprolog-document-predicate-at-point= for interactively creating
=PlDoc= comments for predicates in =sweeprolog-mode= buffers.  This
command, bound by default to =C-c C-d=, finds the beginning of the
predicate definition under or right above the current cursor location,
and inserts formatted =PlDoc= comments while prompting the user to
interactively fill in the argument modes, determinism specification,
and initial contents of the predicate documentation.
=sweeprolog-document-predicate-at-point= leaves the cursor at the end of
the newly inserted documentation comment for the user to extend or
edit it if needed.  To add another comment line, use =M-j=
(=comment-indent-new-line=) which starts a new line with the comment
prefix filled in.  To reformat the current paragraph of =PlDoc=
comments, use =M-q= (=fill-paragraph=).

For more information about =PlDoc= and source documentation in
SWI-Prolog, see [[https://www.swi-prolog.org/pldoc/doc_for?object=section(%27packages/pldoc.html%27)][the PlDoc manual]].

** Displaying predicate documentation
:PROPERTIES:
:CUSTOM_ID: eldoc-integration
:END:

=sweep= integrates with the Emacs minor mode =ElDoc=, which automatically
displays documentation for the predicate at point.  Whenever the
cursor enters a predicate definition or invocation, the signature and
summary of that predicate are displayed in the echo area at the bottom
of the frame.

#+VINDEX: sweeprolog-enable-eldoc
To disable the =ElDoc= integration in =sweeprolog-mode= buffers, customize
the user option =sweeprolog-enable-eldoc= to nil.

* The Prolog top-level
:PROPERTIES:
:CUSTOM_ID: prolog-top-level
:END:

#+CINDEX: top-level
#+FINDEX: sweeprolog-top-level
=sweep= provides a classic Prolog top-level interface for interacting
with the embedded Prolog runtime.  To start the top-level, use =M-x
sweeprolog-top-level=.  This command opens a buffer called =*sweeprolog-top-level*=
which hosts the live Prolog top-level.

#+FINDEX: sweeprolog-top-level-mode
#+VINDEX: sweeprolog-top-level-mode
The top-level buffer uses a major mode named
=sweeprolog-top-level-mode=. This mode derives from =comint-mode=, which is the
common mode used in Emacs REPL interfaces.  As a result, the top-level
buffer inherits the features present in other =comint-mode= derivatives,
most of which are described in [[info:emacs#Shell Mode][the Emacs manual]].

** Multiple top-levels
:PROPERTIES:
:CUSTOM_ID: multiple-top-levels
:END:

Any number of top-levels can be created and used concurrently, each in
its own buffer.  If a top-level buffer already exists, =sweeprolog-top-level=
will simply open it by default.  To create another one or more
top-level buffers, run =sweeprolog-top-level= with a prefix argument
(i.e. =C-u M-x sweeprolog-top-level-mode=) to choose a different buffer name.
Alternatively, run the command =C-x x u= (or =M-x rename-uniquely=) in the
buffer called =*sweeprolog-top-level*= and then run =M-x sweeprolog-top-level=
again.  This will change the name of the original top-level buffer to
something like =*sweeprolog-top-level*<2>= and allow the new top-level to
claim the buffer name =*sweeprolog-top-level*=.

** The Top-level Menu buffer
:PROPERTIES:
:DESCRIPTION: A special buffer for operating on active top-levels
:CUSTOM_ID: top-level-menu
:END:

#+CINDEX: Top-level Menu
=sweep= provides a convenient interface for listing the active Prolog
top-levels and operating on them, called the Top-level Menu buffer.
This buffer shows the list of active =sweep= top-level buffers in a
table that includes information and statistics for each top-level.

#+FINDEX: sweeprolog-list-top-levels
To open the Top-level Menu buffer, use the command ~M-x
sweeprolog-list-top-levels~.  By default, the buffer is will be named
=*sweep Top-levels*=.

The Top-level Menu buffer uses a special major mode named
~sweeprolog-top-level-menu-mode~.  This mode provides several commands
that operate on the top-level corresponding to the table row at point.
The available commands are:

- ~RET~ (~sweeprolog-top-level-menu-go-to~) ::

  #+FINDEX: sweeprolog-top-level-menu-go-to
  Open the specified top-level buffer.

- ~k~ (~sweeprolog-top-level-menu-kill~) ::

  #+FINDEX: sweeprolog-top-level-menu-kill
  Kill the specified top-level buffer.

- ~s~ (~sweeprolog-top-level-menu-signal~) ::

  #+FINDEX: sweeprolog-top-level-menu-signal
  Signal the specified top-level buffer (see [[*Sending signals to running top-levels][Sending signals to
  running top-levels]]).

- ~t~ (~sweeprolog-top-level-menu-new~) ::

  #+FINDEX: sweeprolog-top-level-menu-new
  Create a new top-level buffer.

- ~g~ (~revert-buffer~) ::

  Update the Top-level Menu contents.

** Sending signals to running top-levels
:PROPERTIES:
:CUSTOM_ID: top-level-signals
:END:

#+CINDEX: signaling Prolog threads
#+FINDEX: sweeprolog-top-level-signal
When executing long running Prolog queries in the top-level, there may
arise a need to interrupt the query, either to inspect the state of
the top-level or to free it for running other queries.  To signal a
=sweep= top-level that it should stop executing the current query and do
something else instead, use the command ~M-x
sweeprolog-top-level-signal~.  This command prompts for an active =sweep=
top-level buffer followed by a Prolog goal, and interrupts the
top-level causing it to run the specified goal.

#+FINDEX: sweeprolog-top-level-signal-current
In ~sweeprolog-top-level-mode~ buffers, the command
~sweeprolog-top-level-signal-current~ is available for signaling the
current top-level.  It is bound by default to ~C-c C-c~.

It is also possible to signal top-levels from the =sweep= Top-level Menu
buffer with the command ~sweeprolog-top-level-menu-signal~ with point at
the entry corresponding to the wanted top-level (see [[The Top-level
Menu buffer]]).

For more information about interrupting threads in SWI-Prolog, see
[[https://www.swi-prolog.org/pldoc/man?section=thread-signal][Signaling threads in the SWI-Prolog manual]].

** Top-level history
:PROPERTIES:
:CUSTOM_ID: top-level-history
:END:

=sweeprolog-top-level-mode= buffers provide a history of previously user
inputs, similarly to other =comint-mode= derivatives such as =shell-mode=.
To insert the last input from the history at the prompt, use =M-p=
(=comint-previous-input=).  For a full description of history related
commands, see [[info:emacs#Shell History][Shell History in the Emacs manual]].

#+VINDEX: sweeprolog-top-level-min-history-length
The =sweep= top-level history only records inputs whose length is at
least =sweeprolog-top-level-min-history-length=.  This user option is set to
3 by default, and should generally be set to at least 2 to keep the
history from being clobbered with single-character inputs, which are
common in the top-level interaction, e.g. =;= as used to invoke
backtracking.

** Completion in the top-level
:PROPERTIES:
:CUSTOM_ID: completion-in-top-level
:END:

The =sweeprolog-top-level-mode=, enabled in the =sweep= top-level buffer,
integrates with the standard Emacs symbol completion mechanism to
provide completion for predicate names.  To complete a partial
predicate name in the top-level prompt, use =C-M-i= (or =M-<TAB>=).  For
more information see [[info:emacs#Symbol Completion][Symbol Completion in the Emacs manual]].

* Finding Prolog code
:PROPERTIES:
:CUSTOM_ID: finding-prolog-code
:END:

#+FINDEX: sweeprolog-find-module
=sweep= provides the command =M-x sweeprolog-find-module= for
selecting and jumping to the source code of a loaded or auto-loadable
Prolog module.  =sweep= integrates with Emacs' standard completion API
to annotate candidate modules in the completion UI with their =PLDoc=
description when available.

#+FINDEX: sweeprolog-find-predicate
Along with =M-x sweeprolog-find-module=, =sweep= provides the
command =M-x sweeprolog-find-predicate= jumping to the definition a
loaded or auto-loadable Prolog predicate.

** Prolog file specification expansion
:PROPERTIES:
:CUSTOM_ID: file-spec-expansion
:END:

=sweep= defines a handler for the Emacs function =expand-file-file= that
recognizes Prolog file specifications, such as =library(lists)=, and
expands them to their corresponding absolute paths.  This means that
one can use Prolog file specifications with Emacs' standard =find-file=
(=C-x C-f=) to locate Prolog resources directly.

For example, typing =C-x C-f library(pldoc/doc_man)= will open the
source of the =pldoc_man= module from the Prolog library, and likewise
=C-x C-f pack(.)= will open the Prolog packages directory.

* Quick access to sweep commands
:PROPERTIES:
:CUSTOM_ID: quick-command-access
:END:

#+VINDEX: sweeprolog-prefix-map
=sweep= defines a keymap called =sweeprolog-prefix-map= which provides
keybinding for several useful =sweep= commands.  By default,
=sweeprolog-prefix-map= itself is not bound to any key.  To bind it globally
to a prefix key, e.g. =C-c p=, use:

#+begin_src emacs-lisp
  (keymap-global-set "C-c p" sweeprolog-prefix-map)
#+end_src

As an example, with the above binding the =sweep= top-level can be
accessed from anywhere with =C-c p t=, which invokes the command
=sweeprolog-top-level=.

* Examining Prolog messages
:PROPERTIES:
:CUSTOM_ID: prolog-messages
:END:

#+CINDEX: messages
#+VINDEX: sweeprolog-messages-buffer-name
Messages emitted by the embedded Prolog are redirected by =sweep= to a
dedicated Emacs buffer.  By default, the =sweep= messages buffer is
named =*sweep Messages*=.  To instruct =sweep= to use another buffer name
instead, type =M-x customize-option RET sweeprolog-messages-buffer-name RET=
and set the option to a suitable value.

The =sweep= messages buffer uses the minor mode =compilation-minor-mode=,
which allows for jumping to source locations indicated in errors and
warning directly from the corresponding message in the =sweep= messages
buffer.  For more information about the features enabled by
=compilation-minor-mode=, see [[info:emacs#Compilation Mode][Compilation Mode in the Emacs manual]].

#+FINDEX: sweeprolog-view-messages
=sweep= includes the command =sweeprolog-view-messages= for quickly switching
to the =sweep= messages buffer.  This command is bound by default in
=sweeprolog-prefix-map= to the =e= key (see [[Quick access to sweep commands]]).

* Setting Prolog flags
:PROPERTIES:
:CUSTOM_ID: prolog-flags
:END:

#+CINDEX: prolog flags
#+FINDEX: sweeprolog-set-prolog-flag
The command =M-x sweeprolog-set-prolog-flag= can be used to interactively
configure the embedded Prolog execution environment by changing the
values of Prolog flags.  This command first prompts the user for a
Prolog flag to set, with completion candidates annotated with their
current values as Prolog flags, and then prompts for a string that
will be read as a Prolog term and set as the value of the chosen flag.
For more information on Prolog flags in SWI-Prolog see [[https://www.swi-prolog.org/pldoc/man?section=flags][Environment
Control in the SWI-Prolog manual]].

As an example, the Prolog flag =double_quotes= controls the
interpretation of double quotes in Prolog code.  By default,
=double_quotes= is set to =string=, so e.g. ="foo"= is read as a SWI-Prolog
string as we can easily validate in the =sweep= top-level:

#+begin_src prolog
?- A = "foo".
A = "foo".
#+end_src

We can change the interpretation of double quotes to denote lists of
character codes, by setting the value the =double_quotes= flag to =codes=
with =M-x sweeprolog-set-prolog-flag RET double_quotes RET codes RET=.
Evaluating =A = "foo"= again exhibits the different interpretation:

#+begin_src prolog
?- A = "foo".
A = [102, 111, 111].
#+end_src

* Installing Prolog packages
:PROPERTIES:
:CUSTOM_ID: prolog-packages
:END:

#+FINDEX: sweeprolog-pack-install
The command =M-x sweeprolog-pack-install= can be used to install
or upgrade a SWI-Prolog =pack=. When selecting a =pack= to install, the
completion candidates are annotated with description and the version
of each package.

* Contributing
:PROPERTIES:
:CUSTOM_ID: contributing
:END:

We highly appreciate all contributions, including bug reports,
patches, improvement suggestions, and general feedback.

For a list of known desired improvements in ~sweep~, see [[*Things to do][Things to do]].

** Setting up sweep for local development
:PROPERTIES:
:CUSTOM_ID: development-setup
:END:

Since the Prolog and C parts of ~sweep~ are intended to be distributed
and installed along with SWI-Prolog (see [[#installation][Installation]]), the easiest
way to set up ~sweep~ for development is to start with a SWI-Prolog
development setup.  Clone the ~swipl-devel~ Git repository, and update
the included ~sweep~ submodule from its master branch:

#+begin_src sh
  $ git clone --recursive https://github.com/SWI-Prolog/swipl-devel.git
  $ cd swipl-devel/packages/sweep
  $ git checkout master
  $ git pull
#+end_src

The directory =swipl-devel/packages/sweep= now contains the development
version of ~sweep~, you can make changes to source files and they will
apply when you (re)build SWI-Prolog.  See [[https://github.com/SWI-Prolog/swipl-devel/blob/master/CMAKE.md#building-from-source][Building SWI-Prolog using
cmake]] for instructions on how to build SWI-Prolog from source.

Changes in the Elisp library =sweeprolog.el= do not require rebuilding
SWI-Prolog, and can be applied and tested directly inside Emacs (see [[info:emacs#Lisp
Eval][Evaluating Elisp in the Emacs manual]]).

Most often rebuilding SWI-Prolog after changing =sweep.c= can be
achieved with the following command executed in
=swipl-devel/packages/sweep=:

#+begin_src sh
  $ ninja -C ../../build
#+end_src

** Submitting patches and bug reports
:PROPERTIES:
:CUSTOM_ID: submitting-patches
:END:

The best way to get in touch with the ~sweep~ maintainers is via [[https://lists.sr.ht/~eshel/dev][the
sweep mailing list]].

#+FINDEX: sweeprolog-submit-bug-report
The command ~M-x sweeprolog-submit-bug-report~ can be used to easily
contact the ~sweep~ maintainers from within Emacs.  This command opens a
new buffer with a message template ready to be sent to the ~sweep~
mailing list.

* Things to do
:PROPERTIES:
:CUSTOM_ID: thigs-to-do
:END:

While ~sweep~ is ready to be used for effective editing of Prolog code,
there some further improvements that we want to pursue:

** Improvements around editing Prolog
:PROPERTIES:
:CUSTOM_ID: todo-editing
:END:

- Inherit user customizations from ~prolog-mode~ :: ~sweep~ should inherit
  user customizations from the standard =prolog.el= built into Emacs to
  accommodate users updating their configs to work with ~sweep~.
  Ideally, ~sweeprolog-mode~ should be derived from ~prolog-mode~ instead
  of the generic ~prog-mode~ to inherit user-set hooks and
  modifications, but careful consideration is required to make sure
  ~sweeprolog-mode~ overrides all conflicting ~prolog-mode~ features.

- Reflect buffer status in the mode line :: It may be useful to
  indicate in the mode line whether the current ~sweeprolog-mode~ buffer
  has been loaded into the Prolog runtime and/or if its
  cross-reference data is up to date.

- Provide right-click (~mouse-3~) menus with ~context-menu-mode~ :: To
  accommodate users who prefer a mouse-based workflow, ~sweeprolog-mode~
  should provide right-click context-aware menus by integrating with
  ~context-menu-mode~.

- Provide descriptions for tokens by setting their ~help-echo~ propety :: We
  should annotate tokens in Prolog code with a short text in their
  ~help-echo~ property that says what kind of token this is, to expose
  the precise semantics of each token to the user.

- Add a command for exporting the current predicate :: ~sweeprolog-mode~
  should provide a command for adding a predicate to the export list
  of the module defined in the current buffer, defaulting to the
  predicate at point.

- Add a command for updating the dependencies for the current module :: ~sweeprolog-mode~
  should provide a command for adding and/or updating ~use_module/2~ and
  ~autoload/2~ directives as needed according to the predicates that the
  current buffer depends on. The directives should be inserted in the
  appropriate position, i.e. before the first predicate definition in
  the buffer.

- Add a command for inserting a new clause, similar to ~C-M-m~ in ~prolog-mode~ :: ~sweeprolog-mode~
  should provide a command for inserting a new clause for the
  predicate at or above point.

- Add a command for interactively inserting a new predicate :: ~sweeprolog-mode~
  should provide a command for interactively inserting a new predicate
  definition, ideally with optional =PlDoc= comments (see [[#sweeprolog-pldoc][Documenting
  predicates]]).

- Add commands for narrowing and moving by predicate definitions :: ~sweeprolog-mode~
  should include commands moving point to the next/previous predicate
  definition.  We already have commands for clause-based motion
  (~C-M-a~, ~C-M-e~) but it would be useful to have predicate-based
  variants as well.  These commands could then be bound to ~C-c C-n~ for
  moving to the next predicate definition and ~C-c C-p~ for moving to
  the previous.

- Integrate with ~flymake~ to provide on-the-fly diagnostics :: ~sweeprolog-mode~
  should integrate with ~flymake~ to provide diagnostics and feedback
  for errors in Prolog code in an Emacs-standard manner.

- Improve the information provided for predicate completion candidates :: predicate
  completion with ~C-M-i~ should annotate each completion candidate with
  the names and modes of its arguments, when available.  E.g. say
  ~foo(+Bar, -Baz)~ instead of ~foo/2~.

- Improve the behavior of predicate completion in the middle of a functor :: When
  invoking predicate completion in the middle of a functor,
  e.g. ~foo<|>bar(~ (where ~<|>~ designates the location of the cursor),
  we should take into account the part that comes after the cursor and
  either restrict completion to candidates that match it as a suffix,
  or delete it after completion.

- Make predicate completion aware of module-qualification :: predicate
  completion should detect when the prefix it's trying to complete
  starts with a module-qualification ~foo:ba<|>~ and restrict completion
  to matching candidates in the specified module.

** Improvements around running Prolog
:PROPERTIES:
:CUSTOM_ID: todo-running
:END:
- Persist top-level history across sessions :: ~sweep~ should persist
  Prolog top-level histories across invocations of
  ~sweeprolog-top-level~, ideally also across different Emacs sessions.

** General improvements
:PROPERTIES:
:CUSTOM_ID: todo-general
:END:
- Facilitate interactive debugging :: ~sweep~ should facilitate
  interactive debugging of SWI-Prolog code.  This is a big topic that
  we don't currently address.  Perhaps this should handled through
  some Debug Adapter Protocol integration similar to what was done in
  ~dap-swi-prolog~ (see [[https://github.com/eshelyaron/debug_adapter/blob/main/README.md][Debug Adapter Protocol for SWI-Prolog]]).

- Integrate with =project.el= adding support for SWI-Prolog packs :: It
  would be nice if ~sweep~ would "teach" =project.el= to detect
  directories containing SWI-Prolog =pack.pl= package definitions as
  root project directories.

- Add command line arguments handling for Prolog flags :: ~sweep~ should
  make it easy to specify Prolog initialization arguments (see [[#prolog-init][Prolog
  initialization and cleanup]]) already in the Emacs command line
  invocation.  One way to achieve that would be to extend
  ~command-line-functions~ with a custom command line arguments handler.

- Extend the provided Elisp-Prolog interface :: Currently, the Elisp
  interface that ~sweep~ provides for querying Prolog only allows
  calling directly to predicates of arity 2 (see [[#querying-prolog][Querying Prolog]]),
  ideally we should provide a (backward-compatible) way for executing
  arbitrary Prolog queries.

#+html: <!--

* Indices
:PROPERTIES:
:CUSTOM_ID: indices
:END:

** Function index
:PROPERTIES:
:INDEX: fn
:CUSTOM_ID: findex
:END:

** Variable index
:PROPERTIES:
:INDEX: vr
:CUSTOM_ID: vindex
:END:

** Concept index
:PROPERTIES:
:INDEX: cp
:CUSTOM_ID: cindex
:END:

#+html: -->
