#+title:                 sweep: SWI-Prolog Embedded in Emacs
#+author:                Eshel Yaron
#+email:                 me@eshelyaron.com
#+language:              en
#+options:               ':t toc:nil author:t email:t num:nil
#+startup:               content indent
#+export_file_name:      sweep.texi
#+texinfo_filename:      sweep.info
#+texinfo_dir_category:  Prolog
#+texinfo_dir_title:     Sweep: (sweep)
#+texinfo_dir_desc:      SWI-Prolog Embedded in Emacs
#+texinfo_header:        @set MAINTAINERSITE @uref{https://eshelyaron.com,maintainer webpage}
#+texinfo_header:        @set MAINTAINER Eshel Yaron
#+texinfo_header:        @set MAINTAINEREMAIL @email{me@eshelyaron.com}
#+texinfo_header:        @set MAINTAINERCONTACT @uref{mailto:me@eshelyaron.com,contact the maintainer}

This manual describes the Emacs package =sweep=, which provides an
embedded SWI-Prolog runtime inside of Emacs.

#+toc: headlines 8 insert TOC here, with eight headline levels

* Overview
:PROPERTIES:
:CUSTOM_ID: overview
:END:

=sweep= is an embedding of SWI-Prolog in Emacs.  It provides an
interface for executing Prolog queries and consuming their results
from Emacs Lisp (see [[Querying Prolog]]).  =sweep= further builds on top of
this interface and on top of the standard Emacs facilities to provide
advanced features for developing SWI-Prolog programs in Emacs.

** High-level architecture
:PROPERTIES:
:CUSTOM_ID: high-level-architecture
:END:

both SWI-Prolog and Emacs Lisp to create a dynamically loaded Emacs
module that contains the SWI-Prolog runtime.  As such, =sweep= has parts
written in C, in Prolog and in Emacs Lisp.


The different parts of =sweep= are structured as follows:

#+CINDEX: sweep-module
- =sweep.c= defines a dynamic Emacs module which is referred to from
  Elisp as =sweep-module=. This module is linked against the SWI-Prolog
  runtime library (=libswipl=) and exposes a subset of the SWI-Prolog C
  interface to Emacs in the form of Elisp functions (see [[Querying
  Prolog]]). Notably, =sweep-module= is responsible for translating Elisp
  objects to Prolog terms and vice versa.

#+CINDEX: sweep.el
- =sweep.el= defines an Elisp library (named simply =sweep=), which builds
  on top of =sweep-module= to provide user-facing commands and
  functionality. It is also responsible for loading and compiling the
  dynamically loaded =sweep-module=.

#+CINDEX: sweep.pl
- =sweep.pl= defines a Prolog module (named, unsurprisingly, =sweep=)
  which is by default arranged by =sweep.el= to be loaded when the
  embedded Prolog runtime is initialized. It contains predicates that
  =sweep.el= invoke through =sweep-module= to facilitate its different
  commands (see [[Finding Prolog code]]).

* Installation
:PROPERTIES:
:CUSTOM_ID: installation
:END:

1. Clone the =sweep= repository:
   #+begin_src sh
     git clone https://git.sr.ht/~eshel/sweep
   #+end_src

2. Optionally, build the C module =sweep-module=:
   #+begin_src sh
     cd sweep
     make
   #+end_src

3. Add =sweep= to Emacs' =load-path=:
   #+begin_src emacs-lisp
     (add-to-list 'load-path "/path/to/sweep")
   #+end_src

4. Load =sweep= into Emacs:
   #+begin_src emacs-lisp
     (require 'sweep)
   #+end_src

   If =sweep-module= is not already built, =sweep= will suggest to build
   it when loaded.

* Prolog initialization and cleanup
:PROPERTIES:
:CUSTOM_ID: prolog-init
:END:

#+FINDEX: sweep-initialize
The embedded SWI-Prolog runtime must be initialized before it can
start executing queries.  In =sweep=, Prolog initialization is done via
the C-implemented =sweep-initialize= Elisp function defined in
=sweep-module=.  =sweep-initialize= takes one or more arguments, which
must all be strings, and initializes the embedded Prolog as if it were
invoked externally in a command line with the given strings as command
line arguments, where the first argument to =sweep-initialize=
corresponds to =argv[0]=.

#+VINDEX: sweep-init-args
By default, =sweep.el= will initialize Prolog automatically when it is
loaded into Emacs.  The arguments used to initialize Prolog in that
case are determined by the value of the user-option =sweep-init-args=
which the user is free to extend with e.g.:

#+begin_src emacs-lisp
  (add-to-list 'sweep-init-args "--stack-limit=512m")
#+end_src

#+VINDEX: sweep-init-on-load
To inhibit =sweep= from initializing Prolog on load, set the user-option
=sweep-init-on-load= to nil.

#+FINDEX: sweep-cleanup
The embedded Prolog runtime can be reset using the =sweep-cleanup=
function.  This function cleans up the Prolog state and resources,
afterwards =sweep-initialize= can be called to start Prolog anew.

* Querying Prolog
:PROPERTIES:
:CUSTOM_ID: querying-prolog
:END:

#+FINDEX: sweep-open-query
=sweep= provides the Elisp function =sweep-open-query= for invoking Prolog
predicates.  The invoked predicate must be of arity two and will be
called in mode =p(+In, -Out)= i.e. the predicate should treat the
first argument as input and expect a variable for the second argument
which should be unified with the some output.  This restriction is
placed in order to facilitate a natural calling convention between
Elisp, a functional language, and Prolog, a logical one.

The =sweep-open-query= function takes five arguments, the first three
are strings which denote:
- The name of the Prolog context module from which to execute the
  query,
- The name of the module in which the invoked predicate is defined,
  and
- The name of the predicate to call.

The fourth argument to =sweep-open-query= is converted into a Prolog
term and used as the first argument of the predicate (see [[Conversion
of Elisp objects to Prolog terms]]).  The fifth argument is an
optional "reverse" flag, when this flag is set to non-nil, the order
of the arguments is reversed such the predicate is called in mode
=p(-Out, +In)= rather than =p(+In, -Out)=.

#+FINDEX: sweep-next-solution
The function =sweep-next-solution= can be used to examine the results of
a query.  If the query succeeded, =sweep-next-solution= returns a cons
cell whose =car= is either the symbol =!= when the success was
deterministic or =t= otherwise, and the =cdr= is the current value of the
second (output) Prolog argument converted to an Elisp object (see
[[Conversion of Prolog terms to Elisp objects]]).  If the query failed,
=sweep-next-solution= returns nil.


#+FINDEX: sweep-cut-query
#+FINDEX: sweep-close-query
=sweep= only executes one Prolog query at a given time, thus queries
opened with =sweep-open-query= need to be closed before other queries
can be opened.  When no more solutions are available for the current
query (i.e. after =sweep-next-solution= returned nil), or when otherwise
further solutions are not of interest, the query must be closed with
either =sweep-cut-query= or =sweep-close-query=. Both of these functions
close the current query, but =sweep-close-query= also destroys any
Prolog bindings created by the query.

** Conversion of Elisp objects to Prolog terms
:PROPERTIES:
:CUSTOM_ID: elisp-to-prolog
:END:

=sweep= converts Elisp objects into Prolog terms to allow the Elisp
programmers to specify arguments for Prolog predicates invocations (see
=sweep-open-query=).  Seeing as some Elisp objects, like Elisp compiled
functions, wouldn't be as useful for a passing to Prolog as others,
=sweep= only converts Elisp objects of certain types to Prolog, namely
we convert /trees of strings and numbers/:

- Elisp strings are converted to equivalent Prolog strings.
- Elisp integers are converted to equivalent Prolog integers.
- Elisp floats are converted to equivalent Prolog floats.
- The Elisp nil object is converted to the Prolog empty list =[]=.
- Elisp cons cells are converted to Prolog lists whose head and tail
  are the Prolog representations of the =car= and the =cdr= of the cons.

** Conversion of Prolog terms to Elisp objects
:PROPERTIES:
:CUSTOM_ID: prolog-to-elisp
:END:

=sweep= converts Prolog terms into Elisp object to allow efficient
processing of Prolog query results in Elisp (see =sweep-next-solution=).

- Prolog strings are converted to equivalent Elisp strings.
- Prolog integers are converted to equivalent Elisp integers.
- Prolog floats are converted to equivalent Elisp floats.
- A Prolog atom =foo= is converted to a cons cell =(atom . "foo")=.
- The Prolog empty list =[]= is converted to the Elisp nil object.
- Prolog lists are converted to Elisp cons cells whose =car= and =cdr= are
  the representations of the head and the tail of the list.
- Prolog compounds are converted to list whose first element is the
  symbol =compound=. The second element is a string denoting the functor
  name of the compound, and the rest of the elements are the arguments
  of the compound in their Elisp representation.
- All other Prolog terms (variables, blobs and dicts) are currently
  represented in Elisp only by their type:
  + Prolog variables are converted to the symbol =variable=,
  + Prolog blobs are converted to the symbol =blob=, and
  + Prolog dicts are converted to the symbol =dict=.

** Example - counting solutions for a Prolog predicate in Elisp
:PROPERTIES:
:CUSTOM_ID: count-permutations
:END:

As an example of using the =sweep= interface for executing Prolog
queries, we show an invocation of the non-deterministic predicate
=lists:permutation/2= from Elisp where we count the number of different
permutations of the list =(1 2 3 4 5)=:

#+name: count-list-permutations
#+begin_src emacs-lisp
  (sweep-open-query "user" "lists" "permutation" '(1 2 3 4 5))
  (let ((num 0)
        (sol (sweep-next-solution)))
    (while sol
      (setq num (1+ num))
      (setq sol (sweep-next-solution)))
    (sweep-close-query)
    num)
#+end_src

** Calling Elisp function inside Prolog queries
:PROPERTIES:
:CUSTOM_ID: funcall-from-prolog
:END:

The =sweep-module= defines the foreign Prolog predicates =sweep_funcall/2=
and =sweep_funcall/3=, which allow for calling Elisp functions from
Prolog code.  These predicates may only be called in the context of a
Prolog query initiated by =sweep-open-query=, i.e. only in the Prolog
thread controlled by Emacs.  The first argument to these predicates is
a Prolog string holding the name of the Elisp function to call.  The
last argument to these predicates is unified with the return value of
the Elisp function, represented as a Prolog term (see [[Conversion of
Elisp objects to Prolog terms]]).  The second argument of
=sweep_funcall/3= is converted to an Elisp object (see [[Conversion of
Prolog terms to Elisp objects]]) and passed as a sole argument to the
invoked Elisp function.  The =sweep_funcall/2= variant invokes the Elisp
function without any arguments.

* The Prolog top-level
:PROPERTIES:
:CUSTOM_ID: prolog-top-level
:END:

#+CINDEX: top-level
#+FINDEX: sweep-top-level
=sweep= provides a classic Prolog top-level interface for interacting
with the embedded Prolog runtime.  To start the top-level, use =M-x
sweep-top-level=.  This command opens a buffer called =*sweep-top-level*=
which hosts the live Prolog top-level.

#+FINDEX: sweep-top-level-mode
#+VINDEX: sweep-top-level-mode
The top-level buffer uses a major mode named
=sweep-top-level-mode=. This mode derives from =comint-mode=, which is the
common mode used in Emacs REPL interfaces.  As a result, the top-level
buffer inherits the features present in other =comint-mode= derivatives,
most of which are described in [[info:emacs#Shell Mode][the Emacs manual]].

** Multiple top-levels
:PROPERTIES:
:CUSTOM_ID: multiple-top-levels
:END:

Any number of top-levels can be created and used concurrently, each in
its own buffer.  If a top-level buffer already exists, =sweep-top-level=
will simply open it by default.  To create another one or more
top-level buffers, run =sweep-top-level= with a prefix argument
(i.e. =C-u M-x sweep-top-level-mode=) to choose a different buffer name.
Alternatively, run the command =C-x x u= (or =M-x rename-uniquely=) in the
buffer called =*sweep-top-level*= and then run =M-x sweep-top-level=
again.  This will change the name of the original top-level buffer to
something like =*sweep-top-level*<2>= and allow the new top-level to
claim the buffer name =*sweep-top-level*=.

** Completion in the top-level
:PROPERTIES:
:CUSTOM_ID: completion-in-top-level
:END:

The =sweep-top-level-mode=, enabled in the =sweep= top-level buffer,
integrates with the standard Emacs symbol completion mechanism to
provide completion for predicate names.  To complete a partial
predicate name in the top-level prompt, use =C-M-i= (or =M-<TAB>=).  For
more information see [[info:emacs#Symbol Completion][Symbol Completion in the Emacs manual]].

* Finding Prolog code
:PROPERTIES:
:CUSTOM_ID: finding-prolog-code
:END:

#+FINDEX: sweep-find-module
=sweep= provides the command =M-x sweep-find-module= for
selecting and jumping to the source code of a loaded or auto-loadable
Prolog module.  =sweep= integrates with Emacs' standard completion API
to annotate candidate modules in the completion UI with their =PLDoc=
description when available.

#+FINDEX: sweep-find-predicate
Along with =M-x sweep-find-module=, =sweep= provides the
command =M-x sweep-find-predicate= jumping to the definition a
loaded or auto-loadable Prolog predicate.

* Installing Prolog packages
:PROPERTIES:
:CUSTOM_ID: prolog-packages
:END:

#+FINDEX: sweep-pack-install
The command =M-x sweep-pack-install= can be used to install
or upgrade a SWI-Prolog =pack=. When selecting a =pack= to install, the
completion candidates are annotated with description and the version
of each package.

* Quick access to =sweep= commands
:PROPERTIES:
:CUSTOM_ID: quick-command-access
:END:

#+VINDEX: sweep-prefix-map
=sweep= defines a keymap called =sweep-prefix-map= which provides
keybinding for several useful =sweep= commands.  By default,
=sweep-prefix-map= itself is not bound to any key.  To bind it globally
to a prefix key, e.g. =C-c p=, use:

#+begin_src emacs-lisp
  (keymap-global-set "C-c p" sweep-prefix-map)
#+end_src

As an example, with the above binding the =sweep= top-level can be
access from anywhere with =C-c p t=.

* Indices
:PROPERTIES:
:CUSTOM_ID: indices
:END:

** Function index
:PROPERTIES:
:INDEX: fn
:CUSTOM_ID: findex
:END:

** Variable index
:PROPERTIES:
:INDEX: vr
:CUSTOM_ID: vindex
:END:

** Concept index
:PROPERTIES:
:INDEX: cp
:CUSTOM_ID: cindex
:END:
