#+title:                 sweep: SWI-Prolog Embedded in Emacs
#+author:                Eshel Yaron
#+email:                 me@eshelyaron.com
#+language:              en
#+options:               ':t toc:nil author:t email:t num:nil
#+startup:               content indent
#+export_file_name:      sweep.texi
#+texinfo_filename:      sweep.info
#+texinfo_dir_category:  Prolog
#+texinfo_dir_title:     Sweep: (sweep)
#+texinfo_dir_desc:      SWI-Prolog Embedded in Emacs
#+texinfo_header:        @set MAINTAINERSITE @uref{https://eshelyaron.com,maintainer webpage}
#+texinfo_header:        @set MAINTAINER Eshel Yaron
#+texinfo_header:        @set MAINTAINEREMAIL @email{me@eshelyaron.com}
#+texinfo_header:        @set MAINTAINERCONTACT @uref{mailto:me@eshelyaron.com,contact the maintainer}

#+macro: kbd (eval (let ((case-fold-search nil) (regexp (regexp-opt '("SPC" "RET" "LFD" "TAB" "BS" "ESC" "DELETE" "SHIFT" "Ctrl" "Meta" "Alt" "Cmd" "Super" "UP" "LEFT" "RIGHT" "DOWN") 'words))) (format "@@texinfo:@kbd{@@%s@@texinfo:}@@" (replace-regexp-in-string regexp "@@texinfo:@key{@@\\&@@texinfo:}@@" $1 t))))

This manual describes the Emacs package =sweep=, which provides an
embedded SWI-Prolog runtime inside of Emacs.

#+toc: headlines 8 insert TOC here, with eight headline levels

* Overview
:PROPERTIES:
:CUSTOM_ID: overview
:END:

=sweep= is an embedding of SWI-Prolog in Emacs.  It uses the C
interfaces of both SWI-Prolog and Emacs Lisp to create a dynamically
loaded Emacs module that contains the SWI-Prolog runtime. As such,
=sweep= has parts written in C, in Prolog and in Emacs Lisp.

The different parts of =sweep= are structured as follows:

#+CINDEX: sweep-module
- =sweep.c= defines a dynamic Emacs module which is referred to from
  Elisp as =sweep-module=. This module is linked against the SWI-Prolog
  runtime library (=libswipl=) and exposes a subset of the SWI-Prolog C
  interface to Emacs in the form of Elisp functions (see [[Querying
  Prolog]]). Notably, =sweep-module= is responsible for translating Elisp
  objects to Prolog terms and vice versa.

#+CINDEX: sweep.el
- =sweep.el= defines an Elisp library (named simply =sweep=), which builds
  on top of =sweep-module= to provide user-facing commands and
  functionality. It is also responsible for loading and compiling the
  dynamically loaded =sweep-module=.

#+CINDEX: sweep.pl
- =sweep.pl= defines a Prolog module (named, unsurprisingly, =sweep=)
  which is by default arranged by =sweep.el= to be loaded when the
  embedded Prolog runtime is initialized. It contains predicates that
  =sweep.el= invoke through =sweep-module= to facilitate its different
  commands (see [[Finding Prolog code]]).

* Installation
:PROPERTIES:
:CUSTOM_ID: installation
:END:

1. Clone the =sweep= repository:
   #+begin_src sh
     git clone --recursive https://git.sr.ht/~eshel/sweep
   #+end_src

2. Optionally, build the C module =sweep-module=:
   #+begin_src sh
     cd sweep
     make
   #+end_src

3. Add =sweep= to Emacs' =load-path=:
   #+begin_src emacs-lisp
     (add-to-list 'load-path "/path/to/sweep")
   #+end_src

4. Load =sweep= into Emacs:
   #+begin_src emacs-lisp
     (require 'sweep)
   #+end_src

   If =sweep-module= is not already built, =sweep= will suggest to build
   it when loaded. Note that this may take a couple of minutes as the
   SWI-Prolog runtime may need to be built as well.

* Querying Prolog
:PROPERTIES:
:CUSTOM_ID: querying-prolog
:END:

=sweep= provides the Elisp function =sweep-open-query= for initiating
Prolog queries. To examine the results of the query, the function
=sweep-next-solution= is used. When no more solutions are available, or
when otherwise further solutions are not required, the query must be
closed with either =sweep-cut-query= or =sweep-close-query=.

#+FINDEX: sweep-open-query
#+FINDEX: sweep-next-solution
#+FINDEX: sweep-cut-query
#+FINDEX: sweep-close-query

As an example, we show an invocation of the non-deterministic
predicate =lists:permutation/2= from Elisp, which yields the number of
different permutations of the list =(1 2 3 4 5)=:

#+begin_src emacs-lisp
  (sweep-open-query "user" "lists" "permutation" '(1 2 3 4 5))
  (let ((num 0)
        (sol (sweep-next-solution)))
    (while sol
      (setq num (1+ num))
      (setq sol (sweep-next-solution)))
    (sweep-close-query)
    num)
#+end_src

* Finding Prolog code
:PROPERTIES:
:CUSTOM_ID: finding-prolog-code
:END:

#+FINDEX: sweep-find-module
=sweep= provides the command {{{kbd(M-x sweep-find-module)}}} for
selecting and jumping to the source code of a loaded or auto-loadable
Prolog module.  =sweep= integrates with Emacs' standard completion API
to annotate candidate modules in the completion UI with their =PLDoc=
description when available.

#+FINDEX: sweep-find-predicate
Along with {{{kbd(M-x sweep-find-module)}}}, =sweep= provides the
command {{{kbd(M-x sweep-find-predicate)}}} jumping to the definition a
loaded or auto-loadable Prolog predicate.

* Installing Prolog packages

#+FINDEX: sweep-pack-install
The command {{{kbd(M-x sweep-pack-install)}}} can be used to install
or upgrade a SWI-Prolog =pack=. When selecting a =pack= to install, the
completion candidates are annotated with description and the version
of each package.

* Known issues
:PROPERTIES:
:CUSTOM_ID: known-issues
:END:

** Collision between Emacs' and SWI-Prolog's use of GMP
:PROPERTIES:
:CUSTOM_ID: gmp-collision
:END:

Currently, =sweep= builds the SWI-Prolog runtime without GMP support
(using the =cmake= flag =-DUSE_GMP=OFF=). Initializing SWI-Prolog inside
Emacs with GMP support /enabled/ for SWI-Prolog causes Emacs to crash
during garbage collection, because the SWI-Prolog =mp_free= routine is
mistakenly invoked to cleanup Elisp big integers.

Aside from the obvious problem of not being able to utilize SWI-Prolog
support for unbounded integer arithmetic, this issue also prevents us
from using an existing =libswipl= since it is most likely to have been
built with GMP enabled.

* Indices
:PROPERTIES:
:CUSTOM_ID: indices
:END:

** Function index
:PROPERTIES:
:INDEX: fn
:CUSTOM_ID: findex
:END:

** Variable index
:PROPERTIES:
:INDEX: vr
:CUSTOM_ID: vindex
:END:

** Concept index
:PROPERTIES:
:INDEX: cp
:CUSTOM_ID: cindex
:END:
