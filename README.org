#+title:                 sweep: SWI-Prolog Embedded in Emacs
#+author:                Eshel Yaron
#+email:                 me@eshelyaron.com
#+language:              en
#+options:               ':t toc:nil author:t email:t num:nil ^:{}
#+startup:               content indent
#+export_file_name:      sweep.texi
#+texinfo_filename:      sweep.info
#+texinfo_dir_category:  Emacs
#+texinfo_dir_title:     Sweep: (sweep)
#+texinfo_dir_desc:      SWI-Prolog Embedded in Emacs
#+texinfo_header:        @set MAINTAINERSITE @uref{https://eshelyaron.com,maintainer webpage}
#+texinfo_header:        @set MAINTAINER Eshel Yaron
#+texinfo_header:        @set MAINTAINEREMAIL @email{me@eshelyaron.com}
#+texinfo_header:        @set MAINTAINERCONTACT @uref{mailto:me@eshelyaron.com,contact the maintainer}

This manual describes the Emacs package =sweep=, which provides an
embedded SWI-Prolog runtime inside of Emacs.

#+toc: headlines 8 insert TOC here, with eight headline levels

* Overview
:PROPERTIES:
:CUSTOM_ID: overview
:END:

=sweep= is an embedding of SWI-Prolog in Emacs.  It provides an
interface for executing Prolog queries and consuming their results
from Emacs Lisp (see [[Querying Prolog]]).  =sweep= further builds on top of
this interface and on top of the standard Emacs facilities to provide
advanced features for developing SWI-Prolog programs in Emacs.

** High-level architecture
:PROPERTIES:
:CUSTOM_ID: high-level-architecture
:END:

both SWI-Prolog and Emacs Lisp to create a dynamically loaded Emacs
module that contains the SWI-Prolog runtime.  As such, =sweep= has parts
written in C, in Prolog and in Emacs Lisp.


The different parts of =sweep= are structured as follows:

#+CINDEX: sweep-module
- =sweep.c= defines a dynamic Emacs module which is referred to from
  Elisp as =sweep-module=. This module is linked against the SWI-Prolog
  runtime library (=libswipl=) and exposes a subset of the SWI-Prolog C
  interface to Emacs in the form of Elisp functions (see [[Querying
  Prolog]]). Notably, =sweep-module= is responsible for translating Elisp
  objects to Prolog terms and vice versa.

#+CINDEX: sweep.el
- =sweep.el= defines an Elisp library (named simply =sweep=), which builds
  on top of =sweep-module= to provide user-facing commands and
  functionality. It is also responsible for loading and compiling the
  dynamically loaded =sweep-module=.

#+CINDEX: sweep.pl
- =sweep.pl= defines a Prolog module (named, unsurprisingly, =sweep=)
  which is by default arranged by =sweep.el= to be loaded when the
  embedded Prolog runtime is initialized. It contains predicates that
  =sweep.el= invoke through =sweep-module= to facilitate its different
  commands (see [[Finding Prolog code]]).

* Installation
:PROPERTIES:
:CUSTOM_ID: installation
:END:

1. Clone the =sweep= repository:
   #+begin_src sh
     git clone https://git.sr.ht/~eshel/sweep
   #+end_src

2. Optionally, build the C module =sweep-module=:
   #+begin_src sh
     cd sweep
     make
   #+end_src

3. Add =sweep= to Emacs' =load-path=:
   #+begin_src emacs-lisp
     (add-to-list 'load-path "/path/to/sweep")
   #+end_src

4. Load =sweep= into Emacs:
   #+begin_src emacs-lisp
     (require 'sweep)
   #+end_src

   If =sweep-module= is not already built, =sweep= will suggest to build
   it when loaded.

* Prolog initialization and cleanup
:PROPERTIES:
:CUSTOM_ID: prolog-init
:END:

#+FINDEX: sweep-initialize
The embedded SWI-Prolog runtime must be initialized before it can
start executing queries.  In =sweep=, Prolog initialization is done via
the C-implemented =sweep-initialize= Elisp function defined in
=sweep-module=.  =sweep-initialize= takes one or more arguments, which
must all be strings, and initializes the embedded Prolog as if it were
invoked externally in a command line with the given strings as command
line arguments, where the first argument to =sweep-initialize=
corresponds to =argv[0]=.

#+VINDEX: sweep-init-args
By default, =sweep.el= will initialize Prolog automatically when it is
loaded into Emacs.  The arguments used to initialize Prolog in that
case are determined by the value of the user-option =sweep-init-args=
which the user is free to extend with e.g.:

#+begin_src emacs-lisp
  (add-to-list 'sweep-init-args "--stack-limit=512m")
#+end_src

#+VINDEX: sweep-init-on-load
To inhibit =sweep= from initializing Prolog on load, set the user-option
=sweep-init-on-load= to nil.

#+FINDEX: sweep-cleanup
The embedded Prolog runtime can be reset using the =sweep-cleanup=
function.  This function cleans up the Prolog state and resources,
afterwards =sweep-initialize= can be called to start Prolog anew.

* Querying Prolog
:PROPERTIES:
:CUSTOM_ID: querying-prolog
:END:

#+FINDEX: sweep-open-query
=sweep= provides the Elisp function =sweep-open-query= for invoking Prolog
predicates.  The invoked predicate must be of arity two and will be
called in mode =p(+In, -Out)= i.e. the predicate should treat the first
argument as input and expect a variable for the second argument which
should be unified with some output.  This restriction is placed in
order to facilitate a natural calling convention between Elisp, a
functional language, and Prolog, a logical one.

The =sweep-open-query= function takes five arguments, the first three
are strings which denote:
- The name of the Prolog context module from which to execute the
  query,
- The name of the module in which the invoked predicate is defined,
  and
- The name of the predicate to call.

The fourth argument to =sweep-open-query= is converted into a Prolog
term and used as the first argument of the predicate (see [[Conversion
of Elisp objects to Prolog terms]]).  The fifth argument is an
optional "reverse" flag, when this flag is set to non-nil, the order
of the arguments is reversed such that the predicate is called in mode
=p(-Out, +In)= rather than =p(+In, -Out)=.

#+FINDEX: sweep-next-solution
The function =sweep-next-solution= can be used to examine the results of
a query.  If the query succeeded, =sweep-next-solution= returns a cons
cell whose =car= is either the symbol =!= when the success was
deterministic or =t= otherwise, and the =cdr= is the current value of the
second (output) Prolog argument converted to an Elisp object (see
[[Conversion of Prolog terms to Elisp objects]]).  If the query failed,
=sweep-next-solution= returns nil.

#+FINDEX: sweep-cut-query
#+FINDEX: sweep-close-query
=sweep= only executes one Prolog query at a given time, thus queries
opened with =sweep-open-query= need to be closed before other queries
can be opened.  When no more solutions are available for the current
query (i.e. after =sweep-next-solution= returned nil), or when otherwise
further solutions are not of interest, the query must be closed with
either =sweep-cut-query= or =sweep-close-query=. Both of these functions
close the current query, but =sweep-close-query= also destroys any
Prolog bindings created by the query.

** Conversion of Elisp objects to Prolog terms
:PROPERTIES:
:CUSTOM_ID: elisp-to-prolog
:END:

=sweep= converts Elisp objects into Prolog terms to allow the Elisp
programmers to specify arguments for Prolog predicates invocations (see
=sweep-open-query=).  Seeing as some Elisp objects, like Elisp compiled
functions, wouldn't be as useful for a passing to Prolog as others,
=sweep= only converts Elisp objects of certain types to Prolog, namely
we convert /trees of strings and numbers/:

- Elisp strings are converted to equivalent Prolog strings.
- Elisp integers are converted to equivalent Prolog integers.
- Elisp floats are converted to equivalent Prolog floats.
- The Elisp nil object is converted to the Prolog empty list =[]=.
- Elisp cons cells are converted to Prolog lists whose head and tail
  are the Prolog representations of the =car= and the =cdr= of the cons.

** Conversion of Prolog terms to Elisp objects
:PROPERTIES:
:CUSTOM_ID: prolog-to-elisp
:END:

=sweep= converts Prolog terms into Elisp object to allow efficient
processing of Prolog query results in Elisp (see =sweep-next-solution=).

- Prolog strings are converted to equivalent Elisp strings.
- Prolog integers are converted to equivalent Elisp integers.
- Prolog floats are converted to equivalent Elisp floats.
- A Prolog atom =foo= is converted to a cons cell =(atom . "foo")=.
- The Prolog empty list =[]= is converted to the Elisp nil object.
- Prolog lists are converted to Elisp cons cells whose =car= and =cdr= are
  the representations of the head and the tail of the list.
- Prolog compounds are converted to list whose first element is the
  symbol =compound=. The second element is a string denoting the functor
  name of the compound, and the rest of the elements are the arguments
  of the compound in their Elisp representation.
- All other Prolog terms (variables, blobs and dicts) are currently
  represented in Elisp only by their type:
  + Prolog variables are converted to the symbol =variable=,
  + Prolog blobs are converted to the symbol =blob=, and
  + Prolog dicts are converted to the symbol =dict=.

** Example - counting solutions for a Prolog predicate in Elisp
:PROPERTIES:
:CUSTOM_ID: count-permutations
:END:

As an example of using the =sweep= interface for executing Prolog
queries, we show an invocation of the non-deterministic predicate
=lists:permutation/2= from Elisp where we count the number of different
permutations of the list =(1 2 3 4 5)=:

#+name: count-list-permutations
#+begin_src emacs-lisp
  (sweep-open-query "user" "lists" "permutation" '(1 2 3 4 5))
  (let ((num 0)
        (sol (sweep-next-solution)))
    (while sol
      (setq num (1+ num))
      (setq sol (sweep-next-solution)))
    (sweep-close-query)
    num)
#+end_src

** Calling Elisp function inside Prolog queries
:PROPERTIES:
:CUSTOM_ID: funcall-from-prolog
:END:

The =sweep-module= defines the foreign Prolog predicates =sweep_funcall/2=
and =sweep_funcall/3=, which allow for calling Elisp functions from
Prolog code.  These predicates may only be called in the context of a
Prolog query initiated by =sweep-open-query=, i.e. only in the Prolog
thread controlled by Emacs.  The first argument to these predicates is
a Prolog string holding the name of the Elisp function to call.  The
last argument to these predicates is unified with the return value of
the Elisp function, represented as a Prolog term (see [[Conversion of
Elisp objects to Prolog terms]]).  The second argument of
=sweep_funcall/3= is converted to an Elisp object (see [[Conversion of
Prolog terms to Elisp objects]]) and passed as a sole argument to the
invoked Elisp function.  The =sweep_funcall/2= variant invokes the Elisp
function without any arguments.

* Editing Prolog code
:PROPERTIES:
:CUSTOM_ID: editing-prolog-code
:END:

#+CINDEX: sweep-mode
#+FINDEX: sweep-mode
#+VINDEX: sweep-mode
=sweep= includes a dedicated major mode for reading and editing Prolog
code, called =sweep-mode=.  To activate this mode in a buffer, type =M-x
sweep-mode=.  To instruct Emacs to always open Prolog files in
=sweep-mode=, modify the Emacs variable =auto-mode-alist= like so:

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.pl\\'"   . sweep-mode))
  (add-to-list 'auto-mode-alist '("\\.plt\\'"  . sweep-mode))
#+end_src

** Indentation
:PROPERTIES:
:CUSTOM_ID: indentation
:END:

#+CINDEX: indentation

In =sweep-mode= buffers, the appropriate indentation for each line is
determined by a bespoke /indentation engine/.  The indentation engine
analyses the syntactic context of a given line and determines the
appropriate indentation to apply based on a set of rules.

#+FINDEX: sweep-indent-line
The entry point of the indentation engine is the function
=sweep-indent-line= which takes no arguments and indents that line at
point.  =sweep-mode= supports the standard Emacs interface for
indentation by arranging for =sweep-indent-line= to be called whenever a
line should be indented, notably after pressing =TAB=.  For more a full
description of the available commands and options that pertain to
indentation, see [[info:emacs#Indentation][Indentation in the Emacs manual]].

*** Indentation rules
:PROPERTIES:
:CUSTOM_ID: indentation-rules
:END:

Lines in =sweep-mode= buffers are indented according to the following
rules:

1. If the current line starts inside a string or a multi-line comment,
   do not indent.
2. If the current line starts with a top term, do not indent.
3. If the current line starts with a closing parenthesis and the
   matching opening parenthesis is part of a functor, indent to the
   column of the opening parenthesis if any arguments appear on the
   same line as the functor, otherwise indent to the start of the
   functor.

   This rule yields the following layouts:

   #+begin_src prolog
     some_functor(
         some_arg
     ).

     some_functor( some_arg
                 ).
   #+end_src

#+VINDEX: sweep-indent-offset
4. If the current line is the first non-comment line of a clause body,
   indent to the starting column of the head term plus the value of
   the user option =sweep-indent-offset= (by default, four extra
   columns).

   As an example, this rule yields the following layouts when
   =sweep-indent-offset= is set to the default value of four columns:

   #+begin_src prolog
     some_functor(arg1, arg2) :-
         body_term.

     asserta( some_functor(arg1, arg2) :-
                  body_term
            ).
   #+end_src

5. If the current line starts with the right hand side operand of an
   infix operator, indent to the starting column of the first operand
   in the chain of infix operators of the same precedence.

   This rule yields the following layouts:

   #+begin_src prolog
     head :- body1, body2, body3,
             body4, body5.

     A is 1 * 2 ^ 3 * 4 *
          5.

     A is 1 * 2 + 3 * 4 *
                  5.
   #+end_src

6. If the last non-comment line ends with a functor and its opening
   parenthesis, indent to the starting column of the functor plus
   =sweep-indent-offset=.

   This rule yields the following layout:

   #+begin_src prolog
     some_functor(
         arg1, ...
   #+end_src

7. If the last non-comment line ends with a prefix operator, indent to
   starting column of the operator plus =sweep-indent-offset=.

   This rule yields the following layout:

   #+begin_src prolog
     :- multifile
            predicate/3.
   #+end_src

** Semantic highlighting
:PROPERTIES:
:CUSTOM_ID: semantic-highlighting
:END:

#+CINDEX: fontification
=sweep-mode= integrates with the standard Emacs =font-lock= system which
is used for highlighting text in buffers (see [[info:emacs#Font Lock][Font Lock in the Emacs
manual]]).  =sweep-mode= highlights different tokens in Prolog code
according to their semantics, determined through static analysis which
is performed on demand.  When a buffer is first opened in =sweep-mode=,
its entire contents are analyzed to collect and cache cross reference
data, and the buffer is highlighted accordingly.  In contrast, when
editing and moving around the buffer, a faster, local analysis is
invoked to updated the semantic highlighting in response to changes in
the buffer.

#+FINDEX: sweep-colourise-buffer
At any point in a =sweep-mode= buffer, the command =C-c C-c= (or =M-x
sweep-colourise-buffer=) can be used to update the cross reference
cache and highlight the buffer accordingly.  This may be useful
e.g. after defining a new predicate.

#+VINDEX: sweep-colourise-buffer-on-idle
#+VINDEX: sweep-colourise-buffer-max-size
#+VINDEX: sweep-colourise-buffer-min-interval
If the user option =sweep-colourise-buffer-on-idle= is set to non-nil
(as it is by default), =sweep-mode= also updates semantic highlighting
in the buffer whenever Emacs is idle for a reasonable amount of time,
unless the buffer is larger than the value of the
=sweep-colourise-buffer-max-size= user option ( 100,000 by default).
The minimum idle time to wait before automatically updating semantic
highlighting can be set via the user option
=sweep-colourise-buffer-min-interval=.

#+CINDEX: sweep-faces
=sweep= defines more than 60 different faces (named sets of properties
that determine the appearance of a specific text in Emacs buffers, see
also [[info:emacs#Faces][Faces in the Emacs manual]]) to signify the specific semantics of
each token in a Prolog code buffer.  For example, calls to built in
Prolog predicates are highlighted with the =sweep-built-in-face=, while
recursive calls to predicates in their own definitions are assigned
the =sweep-recursion-face=.  The different appearance properties
associated which each face, like color, font, etc., can be customized
according to best suite the user's preferences.  By default, =sweep=
defines its faces to inherit from standard Emacs faces such as
=font-lock-variable-face= commonly used for variables in different
programming languages, which =sweep= uses a basis for
=sweep-variable-face=.  To view and customize all of the faces defined
and used in =sweep=, type =M-x customize-group RET sweep-faces RET=.

** Definitions and references
:PROPERTIES:
:CUSTOM_ID: sweep-xref
:END:

#+CINDEX: xref
=sweep-mode= integrates with the Emacs =xref= API to facilitate quick
access to predicate definitions and references in Prolog code buffers.
This enables the many commands that the =xref= interface provides, like
=M-.= for jumping to the definition of the predicate at point.  Refer to
[[info:emacs#Find Identifiers][Find Identifiers in the Emacs manual]] for an overview of the available
commands.

** Following file specifications
:PROPERTIES:
:CUSTOM_ID: following-file-specs
:END:

#+FINDEX: sweep-find-file-at-point
File specifications that occur in =sweep-mode= buffers can be followed
with =C-c C-o= (or =M-x sweep-find-file-at-point=) whenever point is over
a valid file specification.  For example, consider a Prolog file buffer with the common
directive =use_module/1=:

#+begin_src prolog
:- use_module(library(lists)).
#+end_src

With point in any position inside =library(lists)=, typing =C-c C-o= will
open the =lists.pl= file in the Prolog library.

For more information about file specifications in SWI-Prolog, see
[[https://www.swi-prolog.org/pldoc/doc_for?object=absolute_file_name/3][absolute_file_name/3]] in the SWI-Prolog manual.

** Loading buffers
:PROPERTIES:
:CUSTOM_ID: loading-buffers
:END:

#+CINDEX: loading
#+FINDEX: sweep-load-buffer
The command =M-x sweep-load-buffer= can be used to load the contents of
a =sweep-mode= buffer into the embedded SWI-Prolog runtime.  After a
buffer is loaded, the predicates it defines can be queried from Elisp
(see [[Querying Prolog]]) and from the =sweep= top-level (see [[The Prolog
top-level]]).  In =sweep-mode= buffers, =sweep-load-buffer= is bound by
default to =C-c C-l=.  By default this command loads the current buffer
if its major mode is =sweep-mode=, and prompts for an appropriate buffer
otherwise.  To choose a different buffer to load while visiting a
=sweep-mode= buffer, invoke =sweep-load-buffer= with a prefix argument
(=C-u C-c C-l=).

More relevant information about loading code in SWI-Prolog can be
found in [[https://www.swi-prolog.org/pldoc/man?section=consulting][Loading Prolog source files]] in the SWI-Prolog manual.

* The Prolog top-level
:PROPERTIES:
:CUSTOM_ID: prolog-top-level
:END:

#+CINDEX: top-level
#+FINDEX: sweep-top-level
=sweep= provides a classic Prolog top-level interface for interacting
with the embedded Prolog runtime.  To start the top-level, use =M-x
sweep-top-level=.  This command opens a buffer called =*sweep-top-level*=
which hosts the live Prolog top-level.

#+FINDEX: sweep-top-level-mode
#+VINDEX: sweep-top-level-mode
The top-level buffer uses a major mode named
=sweep-top-level-mode=. This mode derives from =comint-mode=, which is the
common mode used in Emacs REPL interfaces.  As a result, the top-level
buffer inherits the features present in other =comint-mode= derivatives,
most of which are described in [[info:emacs#Shell Mode][the Emacs manual]].

** Multiple top-levels
:PROPERTIES:
:CUSTOM_ID: multiple-top-levels
:END:

Any number of top-levels can be created and used concurrently, each in
its own buffer.  If a top-level buffer already exists, =sweep-top-level=
will simply open it by default.  To create another one or more
top-level buffers, run =sweep-top-level= with a prefix argument
(i.e. =C-u M-x sweep-top-level-mode=) to choose a different buffer name.
Alternatively, run the command =C-x x u= (or =M-x rename-uniquely=) in the
buffer called =*sweep-top-level*= and then run =M-x sweep-top-level=
again.  This will change the name of the original top-level buffer to
something like =*sweep-top-level*<2>= and allow the new top-level to
claim the buffer name =*sweep-top-level*=.

** Top-level history
:PROPERTIES:
:CUSTOM_ID: top-level-history
:END:

=sweep-top-level-mode= buffers provide a history of previously user
inputs, similarly to other =comint-mode= derivatives such as =shell-mode=.
To insert the last input from the history at the prompt, use =M-p=
(=comint-previous-input=).  For a full description of history related
commands, see [[info:emacs#Shell History][Shell History in the Emacs manual]].

#+VINDEX: sweep-top-level-min-history-length
The =sweep= top-level history only records inputs whose length is at
least =sweep-top-level-min-history-length=.  This user option is set to
3 by default, and should generally be set to at least 2 to keep the
history from being clobbered with single-character inputs, which are
common in the top-level interaction, e.g. =;= as used to invoke
backtracking.

** Completion in the top-level
:PROPERTIES:
:CUSTOM_ID: completion-in-top-level
:END:

The =sweep-top-level-mode=, enabled in the =sweep= top-level buffer,
integrates with the standard Emacs symbol completion mechanism to
provide completion for predicate names.  To complete a partial
predicate name in the top-level prompt, use =C-M-i= (or =M-<TAB>=).  For
more information see [[info:emacs#Symbol Completion][Symbol Completion in the Emacs manual]].

* Finding Prolog code
:PROPERTIES:
:CUSTOM_ID: finding-prolog-code
:END:

#+FINDEX: sweep-find-module
=sweep= provides the command =M-x sweep-find-module= for
selecting and jumping to the source code of a loaded or auto-loadable
Prolog module.  =sweep= integrates with Emacs' standard completion API
to annotate candidate modules in the completion UI with their =PLDoc=
description when available.

#+FINDEX: sweep-find-predicate
Along with =M-x sweep-find-module=, =sweep= provides the
command =M-x sweep-find-predicate= jumping to the definition a
loaded or auto-loadable Prolog predicate.

** Prolog file specification expansion
:PROPERTIES:
:CUSTOM_ID: file-spec-expansion
:END:

=sweep= defines a handler for the Emacs function =expand-file-file= that
recognizes Prolog file specifications, such as =library(lists)=, and
expands them to their corresponding absolute paths.  This means that
one can use Prolog file specifications with Emacs' standard =find-file=
(=C-x C-f=) to locate Prolog resources directly.

For example, typing =C-x C-f library(pldoc/doc_man)= will open the
source of the =pldoc_man= module from the Prolog library, and likewise
=C-x C-f pack(.)= will open the Prolog packages directory.

* Quick access to sweep commands
:PROPERTIES:
:CUSTOM_ID: quick-command-access
:END:

#+VINDEX: sweep-prefix-map
=sweep= defines a keymap called =sweep-prefix-map= which provides
keybinding for several useful =sweep= commands.  By default,
=sweep-prefix-map= itself is not bound to any key.  To bind it globally
to a prefix key, e.g. =C-c p=, use:

#+begin_src emacs-lisp
  (keymap-global-set "C-c p" sweep-prefix-map)
#+end_src

As an example, with the above binding the =sweep= top-level can be
accessed from anywhere with =C-c p t=, which invokes the command
=sweep-top-level=.

* Examining Prolog messages
:PROPERTIES:
:CUSTOM_ID: prolog-messages
:END:

#+CINDEX: messages
#+VINDEX: sweep-messages-buffer-name
Messages emitted by the embedded Prolog are redirected by =sweep= to a
dedicated Emacs buffer.  By default, the =sweep= messages buffer is
named =*sweep Messages*=.  To instruct =sweep= to use another buffer name
instead, type =M-x customize-option RET sweep-messages-buffer-name RET=
and set the option to a suitable value.

The =sweep= messages buffer uses the minor mode =compilation-minor-mode=,
which allows for jumping to source locations indicated in errors and
warning directly from the corresponding message in the =sweep= messages
buffer.  For more information about the features enabled by
=compilation-minor-mode=, see [[info:emacs#Compilation Mode][Compilation Mode in the Emacs manual]].

#+FINDEX: sweep-view-messages
=sweep= includes the command =sweep-view-messages= for quickly switching
to the =sweep= messages buffer.  This command is bound by default in
=sweep-prefix-map= to the =e= key (see [[Quick access to sweep commands]]).

* Setting Prolog flags
:PROPERTIES:
:CUSTOM_ID: prolog-flags
:END:

#+CINDEX: prolog flags
#+FINDEX: sweep-set-prolog-flag
The command =M-x sweep-set-prolog-flag= can be used to interactively
configure the embedded Prolog execution environment by changing the
values of Prolog flags.  This command first prompts the user for a
Prolog flag to set, with completion candidates annotated with their
current values as Prolog flags, and then prompts for a string that
will be read as a Prolog term and set as the value of the chosen flag.
For more information on Prolog flags in SWI-Prolog see [[https://www.swi-prolog.org/pldoc/man?section=flags][Environment
Control in the SWI-Prolog manual]].

As an example, the Prolog flag =double_quotes= controls the
interpretation of double quotes in Prolog code.  By default,
=double_quotes= is set to =string=, so e.g. ="foo"= is read as a SWI-Prolog
string as we can easily validate in the =sweep= top-level:

#+begin_src prolog
?- A = "foo".
A = "foo".
#+end_src

We can change the interpretation of double quotes to denote lists of
character codes, by setting the value the =double_quotes= flag to =codes=
with =M-x sweep-set-prolog-flag RET double_quotes RET codes RET=.
Evaluating =A = "foo"= again exhibits the different interpretation:

#+begin_src prolog
?- A = "foo".
A = [102, 111, 111].
#+end_src

* Installing Prolog packages
:PROPERTIES:
:CUSTOM_ID: prolog-packages
:END:

#+FINDEX: sweep-pack-install
The command =M-x sweep-pack-install= can be used to install
or upgrade a SWI-Prolog =pack=. When selecting a =pack= to install, the
completion candidates are annotated with description and the version
of each package.


#+html: <!--

* Indices
:PROPERTIES:
:CUSTOM_ID: indices
:END:

** Function index
:PROPERTIES:
:INDEX: fn
:CUSTOM_ID: findex
:END:

** Variable index
:PROPERTIES:
:INDEX: vr
:CUSTOM_ID: vindex
:END:

** Concept index
:PROPERTIES:
:INDEX: cp
:CUSTOM_ID: cindex
:END:

#+html: -->
